# 코어 자바스크립트 Note

## 06. 프로토타입

- 클래스 기반 언어에서는 '상속'을 사용하지만 프로토타입 기반 언어에서는 어떤 객체를 원형으로 삼고 이를 복제함으로써 상속과 비슷한 효과를 얻는다.

- 자바스크립트 프로토타입 개념을 제대로 이해하는 것만으로도 이미 숙련자 레벨에 도달할 수 있는 시야를 확보하게 되는 셈

### 06-1. 프로토타입 개념 이해

#### 6-1-1. constructor, prototype, instance

```js
var instance = new Constructor();
```

- 어떤 생성자 함수를 new 연산자와 함께 호출하면

- Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스가 생성

- 이때 instance에는 **proto**라는 프로퍼티가 자동으로 부여되는데

- 이 프로퍼티는 Constructor의 prototype이라는 프로퍼티를 참조.

- prototype은 객체이다. 이를 참조하는 **proto** 역시 객체!
  - prototype 객체 내부에는 인스턴스가 사용할 메서드를 저장
  - 인스턴스에도 숨겨진 프로퍼티인 **proto**를 통해 이 메서들에 접근 가능

```js
var Person = function (name) {
  this._name = name;
};
Person.prototype.getName = function () {
  return this._name;
};
var suzi = new Person("Suzi");
suzi.__proto__.getName(); // undefined
```

- instance의 **proto**가 Constructor의 prototype 프로퍼티를 참조하므로 결국 둘은 같은 객체를 바라본다.

- 메서드 호출 결과로 왜 undefined가 나왔나?

  - 'Suzi'가 나오지 않은 것보다 '에러가 발생하지 않았다'가 우선
  - 함수가 아닌 다른 데이터 타입이었다면 실행할 수 없는? TypeError가 발생할 것임
    - 값이 에러가 아닌 다른 값이 나왔으니, getName이 실제로 실행됐고, 이로부터 getName이 함수라는 것은 입증됨

- 함수 내부에서 어떤 값을 반환하나?

  - this.name 값을 리턴하는 내용, this에 원래의 의도와는 다른 값이 할당된 것이 아닐까?
  - 이런 의심을 가지고 로그를 출력하거나 debugger를 지정하는 등 추적하다보면 원인 파악 가능
  - 문제는 바로 this에 바인딩된 대상이 잘못 지정됐다는 것

- 어떤 함수를 '메서드로서' 호출할 때는 메서드명 바로 앞의 객체가 곧 this가 된다.

  - thomas.**proto**.getName()에서 getName 함수 내부에서의 this는 thomas가 아니라 thomas.**proto**라는 객체가 된다.
  - 이 객체 내부에서는 name 프로퍼티가 없으므로 '찾고자 하는 식별자가 정의돼 있지 않을 때는 Error 대신 undefined를 반환한다' 라는 규칙에 의해 undefined가 반환됨.

- 그럼 만약 **proto** 객체에 name 프로퍼티가 있다면?

```js
var suzi = new Person("Suzi");
suzi.__proto__._name = "Suzi__proto__";
suzi.__proto__.getName(); // Suzi_proto
```

- 예상대로 잘 출려괸다. 즉, 관건은 this이다.

  - this를 인스턴스로 할 수 있다면 좋겠다. 그 방법은 \__proto_- 없이 인스턴스에서 곧바로 메서드를 쓰는 것이다.

  ```js
  var suzi = new Person("Suzi", 28);
  suzi.getName(); // Suzi
  var iu = new Person("Jieun", 28);
  iu.getName(); // Jieun
  ```

  - **proto** 를 빼면 this는 instance가 되는게 맞지만, 이대로 메서드가 호출되고 심지어 원하는 값이 나오는 건 이상함

  - 그 이유는? 바로 **proto**가 _생략 가능한_ 프로퍼티이기 때문이다.
  - 원래부터 구조가 생략 가능하도록 정의돼있다.

  ```js
  suzi.__proto__.getName
  -> suzi(.__proto__).getName
  -> suzi.getName
  ```

  - **proto**를 생략하지 않으면 this는 suzi.**proto**를 가리키지만, 이를 생략하면 suzi를 가리킨다.

  - 함수에 자동으로 객체인 prototype 프로퍼티를 생성해 놓는데, 해당 함수를 생성자 함수로서 사용할 경우, 즉 new 연산자와 함께 호출할 경우, 인스턴스에는 숨겨진 프로퍼티인 **proto**가 자동 생성되며, 이 프로퍼티는 생성자 함수의 prototype 프로퍼티를 참조한다.

  - **proto** 프로퍼티는 생략 가능하도록 구현 돼있기 때문에 \*\*생성자 함수의 prototype에 어떤 메서드나 프로퍼티가 있다면 인스턴스에도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근할 수 있게 된다.
