## 콜백 함수

### 4-1 콜백 함수란?

콜백함수는 다른 코드의 인자로 넘겨주는 함수

콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행

### 4-2 제어권

콜백 함수는 제어권과 관련 있음

콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권을 가짐

- 4-2-1 호출 시점

```js
var timer = setInterval(cbFunc, 300);
```

setInerval에 전달한 첫 번째 인자인 cbFunc 함수(이 함수가 콜백 함수입니다)는 0.3초마다 자동으로 실행

- 4-2-2 인자

```js
Array.prototype.map(callback[, thisArg]) //(1)
callback: function(currentValue, index, array) //(2)
```

(1) map 메서드는 첫 번째 인자로 callback 함수를 받고, 생략 가능한 두 번째 인자로 콜백함수 내부에서 this로 인식할 대상을 특정 할 수 있음

thisArg를 생략할 경우에는 일반적인 함수와 마찬가지로 전역객체가 바인딩됨

map 메서드는 메서드의 대상이 되는 배열의 모든 요소들을 처음부터 끝가지 하나씩 꺼내어 콜백 함수를 반복 호출, 콜백함수의 실행 결과들을 모아 새로운 배열 생성

(2) 콜백 함수의 첫 번째 인자에는 배열의 요소 중 현재값이, 두 번재 인자에는 현재값의 인덱스가, 세 번째 인자에는 map 메서드의 대상이 되는 배열 자체가 담김

**콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수를 호출할 때 인자에 어떤 값들을 어떤 순서로 넘길 것인지에 대한 제어권을 가짐**

- 4-2-3 this

  - this에 다른 값이 담기는 이유

    제어권을 넘겨받을 코드에서 call/apply 메서드의 첫 번째 인자에 콜백 함수 내부에서의 this가 될 대상을 명시적으로 바인딩하기 때문

### 4-3 콜백 함수는 함수다

콜백 함수는 함수임

콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로 호출

```js
var obj = {
  vals: [1, 2, 3],
  logValues: function (v, i) {
    console.log(this, v, i);
  },
};
obj.logValues(1, 2); // 7번째 줄
[4, 5, 6].forEach(obj.logValues); // 8번째 줄
```

obj 객체의 logValues 는 메서드로 정의

7번째 줄에서는 이 메서드의 이름 앞에 점이 있으니 메서드로서 호출, this는 obj

8번째 줄에서는 이 메서드를 forEach 함수의 콜백 함수로 전달

obj.logValues가 가리키는 함수만 전달한 것, this는 전역객체

### 4-4 콜백 함수 내부의 this에 다른 값 바인딩하기

- 콜백 함수 내부에서 this가 객체를 바라보게 하는 법

  - this를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 this 대신 그 변수를 사용하게 하고, 이를 클로저로 만든는 방식 -> this 사용❌, 번거롭다
  - this를 우회적으로나마 활용하기

  ```js
  ...
  var obj2 = {
    name: 'obj2',
    func: obj.func
  };

  var callback2 = obj2.func();
  setTimeout(callback2, 1500);

  var obj3 = {name: 'obj3'};
  var callback3 = obj1.func.call(ob3);
  setTimeout(callback3, 2000);
  ```

  callback2에는 (obj1의 func를 복사한) obj2의 func를 실행한 결과를 담아 이를 콜백으로 사용 -> 실행 시점으로부터 1.5초 후에는 'obj2'가 출력

  callback3의 경우 obj1의 func를 실행하면서 this를 obj3가 되도록 지정해 이를 콜백으로 사용 -> 실행 시점으로부터 2초 후에는 'obj3'가 출력

  - bind 메서드

### 4-5 콜백 지옥과 비동기 제어

- 콜백 지옥과 비동기제어란?

콜백 지옥: 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여스기 수준이 감당하기 힘들 정도로 깊어지는 형상

주로 비동기적인 작업(이벤트 처리, 서버 통신)을 수행할 때 등장 -> 가독성 ⬇, 코드 수정 어려움

비동기: 동기의 반대말

동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행

비동기적인 코드는 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어감

**별도의 요청, 실행 대기, 보류** 등과 관련된 코드는 비동기적인 코드임

- 콜백 지옥 해결법

1. 익명의 콜백 함수를 모두 기명함수로 전환 -> 일회성 함수를 전부 변수에 할당하는 것이 마뜩잖음

2. ES6의 Promise와 Generator

   **Promise**: 비동기 작업이 완료될 때 비로소 resolve 또는 reject를 호출하는 방법으로 비동기 작업의 동기적 표현이 가능

   순서

   -> new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출할 대 바로 실행되지만 그 내부에 resolve 또는 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음(then) 또는 오류 구문(catch)으로 넘어가지 않음

   **Generator**: 비동기 작업이 완료되는 시점마다 next 메서드를 호출해준다면 Generator 함수 내부의 소스가 위에서부터 아래로 순차적으로 진행

   '\*'이 붙은 함수가 바로 Generator 함수

   Generator 함수를 실행하면 Iterator가 반환, Iterator는 next라는 메서드를 가지고 있음

   순서

   -> next 메서드 호출

   -> Generator 함수 내부에서 가장 먼저 등장하는 yield에서 함수 실행을 멈춤

   -> next 메서드를 호출하면 앞서 멈췄던 부분부터 시작해서 그 다음에 등장하는 yield에서 함수의 실행을 멈춤

3. ES2017의 async/await

   **Promise + Async/await**

   순서

   -> 비동기 작업을 수행하고자 하는 함수 앞에 async를 표기

   -> 함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 await를 표기하는 것만으로 뒤의 내용을 Promise로 자동 전환

   -> 해당 내용이 resolve된 이후에야 다음으로 진행
