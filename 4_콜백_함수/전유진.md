# 4. 콜백 함수

## 1. 콜백 함수란?

콜백 함수 : 다른 코드의 인자로 넘겨주는 함수 
특징 - 제어권을 넘겨줌(fun1 → fun2)
     - 내부 로직에 의해 적절한 시점에 실행

## 2. 제어권

### 2-1. 호출 시점

콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시점에 대한 제어권 가짐

### 2-2. 인자 

```js
Array.prototype.map(callback[, thisArg])
callback: function(currentValue, index, array)
```

**map 메서드 특징**
- 첫 번째 인자로 callback 함수받고, 생략 가능한 두 번째 인자로 콜백 함수 내부에서 this로 인식할 대상 특정 가능
- thisArg 생략 시 일반 함수와 같이 전역객체 바인딩
- 배열 모든 요소들을 꺼내 콜백 함수 반복 호출 후 새 배열 생성

    *인자 순서*
    - 컴퓨터는 순서에 의해서만 구분.인식
    - 순서 바뀔 시 다른 결과 발생
    - 콜백 함수의 제어권을 넘겨받은 코드는 콜백 함수 호출 시 인자에 어떤 값을 어떤 순서로 넘길 지 제어권 지님

### 2-3. this

"기본적으로 this가 전역객체를 참조하지만 제어권을 넘겨받을 코드에서 콜백 함수에 별도로 this가 될 대상을 
지정한 경우, 그 대상을 참조"

*map 메서드 내*
- 메서드 구현의 핵심은 call/apply에 있음
- this에 thisArg 값 존재 시 그 값 지정, 없을 시 전역객체 지정
- 제어권을 넘겨받을 코드에서 call/apply 메서드의 첫 번째 인자에 콜백 함수 내부에서의 this가 될 대상을 
    명시적으로 바인딩 → this에 다른 값이 담김 

```js
setTimeout(function () { console.log(this); }, 300);

[1, 2, 3, 4, 5].forEach(function (x) {
    console.log(this);
});

document.body.innerHTML += '<button id="a">클릭</button>';
document.body.querySelector('#a')
    .addEventListener('click', function (e) {
        console.log(this, e);
    }
);
```

1. setTimeout은 내부에서 콜백 함수 호출 시 call 메서드의 첫 인자에 전역객체 넘김 → this : 전역객체
2. forEach는 '별도의 인자로 this를 받는 경우'에 해당하지만 별도의 인자로 this를 넘기지 X → 전역객체 
3. addEventListener는 내부 콜백 함수 호출 시 call 메서드 첫 인자에 this를 그대로 넘기도록 정의 → 호출 주체인 HTML 엘리먼트

## 3. 콜백 함수는 함수다

콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로서 호출

```js
var obj = {
    vals: [1, 2, 3],
    logValues: function(v, i) {
        console.log(this, v, i);
    }
};
obj.logValues(1, 2);                // { vals: [1,2,3], logValues: f } 1 2
[4, 5, 6].forEach(obj.logValues);   // Window { ... } 4 0
                                    // Window { ... } 5 1
                                    // Window { ... } 6 2
```

1. 7번째 줄에서는 메서드 앞에 .이 있으니 메서드로 호출 → this : obj
2. 8번째 줄에서는 forEach 함수의 콜 백 함수로서 전달 되어 obj.logValues가 가리키는 함수만 전달
3. obj와의 직접적인 연관이 사라져 별도로 this를 지정하는 인자 지정 X → this : 전역객체 

→ 함수의 인자에 객체의 메서드를 전달하더라도 이는 결국 메서드가 아닌 함수일 뿐~!

## 4. 콜백 함수 내부의 this에 다른 값 바인딩하기

콜백 함수 내부에서 this가 객체를 바라보게 하려면?
    - 별도의 인자로 this를 받는 함수 ok
    - but 그렇지 않은 경우 this의 제어권도 넘겨주므로 사용자가 임의로 값 변경 X

    → this를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 this 대신 그 변수 사용,
        이를 클로저로 사용(전통적 방법)

*함수 재활용(this의 우회적 사용)*
- call 메서드 활용: this를 우회적으로나마 활용함으로써 다양한 상황에서 원하는 객체를 바라보는 콜백 함수 생성

- 처음부터 바라볼 객체를 명시적으로 지정하면 다른 객체를 바라보게끔 할 수 X
- 불편하고 메모리 낭비의 측면 존재
→ 전통적 방식의 아쉬움을 보완하는 bind 메서드 이용!

**콜백 함수 내부의 this에 다른 값을 바인딩하는 법**

```js 
var obj1 = {
    name: 'obj1',
    func: function () {
        console.log(this.name);
    }
};

setTimeout(obj1.func.bind(obj1), 1000);

var obj2 = { name: 'obj2' };
setTimeout(obj1.func.bind(obj2), 1500);
```

## 5. 콜백 지옥과 비동기 제어 

콜백 지옥: "콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 
            감당하기 힘들 정도로 깊어지는 현상"

- 주로 이벤트 처리나 서버 통신과 같이 비동기적 작업 수행에서 발생
- 가독성이 떨어질뿐더러 코드 수정 또한 어려움

? 비동기란: 동기의 반대말로 동기적인 코드는 현재 실행 중인 코드가 완료된 후에야 다음 코드 실행하는 방식
비동기적인 코드: 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드 실행(요청/실행 대기/보류)

    동기- CPU 계산에 의해 즉시 처리 가능한 코드
    비동기  - 사용자의 요청에 의해 시간 경과까지 함수 실행 보류  
            - 사용자의 직접적인 개입에 의해 함수를 실행하도록 대기
             - 웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을때 
                비로소 함수를 실행하도록 대기

- 콜백 함수 → 기명함수 전환: 가독성 문제와 어색함을 동시에 해결하는 가장 간단한 방법

**기명함수로 변환**

- 코드의 가독성을 높이고 함수 선언과 호출만 구분한다면 순서대로 읽어내려가는데 어려움 X
- 변수 최상단 호이스팅으로 외부 노출은 전체를 즉시 실행 함수 등으로 감싸면 해결
    - but 코드명을 따라다녀야하는 어려움 존재 

ES6: Promise, Generator 등이 도입
ES2017: async/await 도입

*Promise + Async/await
- async/await: 비동기 작업을 수행하고자 하는 함수 앞에 async 표기, 함수 내부에서 실질적인 비동기 작업 필요 위치마다 await 표기
- 뒤의 내용을 Promise로 자동 전환하고 해당 내용이 resolve된 이후에야 다음으로 진행
- 즉, Promise의 then과 흡사한 효과

## 6. 정리 

- 콜백 함수는 다른 코드에 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수
- 제어권을 넘겨받은 코드는 다음과 같은 제어권을 지님
    1. 콜백 함수를 호출하는 시점을 스스로 판단, 실행
    2. 콜백 함수를 호출할 때 인자로 넘겨줄 값들 및 그 순서가 정해져 있음. 이 순서를 따르지 않고 코드 작성 시
    엉뚱한 겨로가를 얻음
    3. 콜백 함수의 this가 무엇을 바라보도록 할지가 정해져 있는 경우도 존재. 정하지 않은 경우에는 전역객체 바라봄.
    사용자가 임의로 this를 바꾸고 싶을 경우 bind 메서드 활용!




