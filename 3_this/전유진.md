# 3. this

- 자바스크립트에서 가장 헷갈리는 개념!
- 넓은 사용 범위 
- this가 바라보는 대상을 찾기 힘든 경우 존재
→ 정확한 작동 방식 이해하기

- 함수와 객체(메서드)을 구분하는 유일한 기능
- 상황별 this의 변화 추적해보기*

## 1. 상황에 따라 달라지는 this

this의 결정 : 실행 컨텍스트 생성 시(함수 호출)

### 1-1. 전역 공간에서의 this

- 전역 공간 -> this는 전역 객체를 가리킴
    - 브라우저 환경 : window
    - Node.js 환경 : global

*전역 공간에서만 발생하는 특이성질*

```js
var a = 1;
console.log(a);        // 1
console.log(window.a); // 1
console.log(this.a);   // 1
```

- 전역 변수 선언 시 전역 객체의 프로퍼티로 할당
? 전역 공간에서 this는 전역 객체를 의미하니 동일하지만 값이 1인 이유
→ 자바스크립트 엔진이 특정 객체의 프로퍼티로 인식하기 때문

*전역 변수 선언과 프로퍼티 할당 - 삭제*

- 전역 객체의 프로퍼티로 할당 시 삭제
- 전역변수로 선언 시 삭제 X
- 전역 객체의 프로퍼티 할당과 동시에 변경 및 삭제 기능 false
→ 사용자가 의도치 않게 삭제하는 경우 방지

### 1-2. 메서드로 호출 시 메서드 내부에서의 this

**함수 vs. 메서드**

- 함수 실행법 
    - 함수로서 호출
    - 메서드로서 호출

    - 차이 : 독립성 여부
    - 메서드 : 할당 + 호출 시에만 동작

```js 
var func = function (x) {
    console.log(this, x);
};
func(1); // window { ... } 1

var obj = {
    method: func
};
obj.method(2); // { method: f } 2
```

- 차이: 변수에 담아 호출한 경우 / obj 객체의 프로퍼티에 할당해 호출한 경우
- 구분: 함수 앞에 점(.)의 여부
- 함수 호출 시 함수 이름 앞에 객체 명시 시, 메서드로서 호출 
- 이외에는 함수 호출

*메서드 내부에서의 this*

- this에 호출 주체 정보 담김
- 호출 주체 : 함수명 앞의 객체
    - 점 표기법 - 마지막 점 앞에 명시된 객체 = this

### 1-3. 함수로 호출할 때 그 함수 내부에서의 this 

**함수 내부에서의 this**

- 함수로서 호출 시 this 지정되지 X
→ 전역 객체를 바라봄

**메서드의 내부함수에서의 this**

- 헷갈리기 쉬우며 실제 동작과 다르게 예측하는 경우 많음
- 함수로서의 호출과 메서드로서의 호출 파악 필요

! 같은 함수임에도 호출법에 따라 바인딩되는 this의 대상에 차이 존재 

*메서드의 내부 함수에서의 this 우회법*

- 호출 주체 미존재 시 주변 환경의 this 상속 사용 want.
→ 직전 컨텍스트의 this를 바라보게 하기 위함
    - 변수를 활용하여 우회 가능(self)

**this를 바인딩하지 않는 함수**

- 화살표 함수 : 실행 컨텍스트 생성 시 this 바인딩 과정 삭제
- 상위 스코프의 this 그대로 활용 가능 
→ 우회법 불필요

```js
var obj = {
    outer: function () {
        console.log(this);          // {outer: f}
        var innerFunc = () => {
            console.log(this);      // {outer: f}
        };
        innerFunc();
    }
};
obj.outer();
```

- 이외에 call, apply 등의 방법 존재 

### 1-4. 콜백 함수 호출 시 그 함수 내부에서의 this

- 콜백 함수 = 제어권 양도 : func1 -> func2
- func1은 func2의 내부 로직에 따라 실행
- this 또한 func2 규칙에 따라 값 결정
- 별도로 this가 될 대상 지정 시 그 대상 참조 
→ 제어권을 가지는 함수가 콜백 함수에서의 this를 무엇으로 할지 결정 
    특별히 미정의 시 기본적으로 전역객체 바라봄

### 1-5. 생성자 함수 내부에서의 this

- 생성자 함수 : 공통된 성질을 지니는 객체 생성에 사용
- 객체 지향 언어 
    - 생성자: 클래스 
    - 인스턴스: 클래스를 통해 만든 객체

- new 명령어와 함수 호출 시 함수가 생성자로서 동작
- 생성자 함수로서 호출 시 내부 this는 새 인스턴스 자신이 됨

- 구체적 인스턴스 생성
    1. 생성자 함수 호출 
    2. 생성자의 prototype 프로퍼티 참조하는 객체 생성
    3. 미리 준비된 공통 속성 및 개성을 해당 객체에 부여

## 2. 명시적으로 this를 바인딩하는 방법

- 규칙을 깨고 this에 별도 대상 바인딩 가능

### 2-1. call 메서드 

- call 메서드 : 메서드의 호출 주체인 함수 즉시 실행 명령
- call 메서드의 첫번째 인자를 this로 바인딩
- 이후 인자들을 호출할 함수의 매개변수로 지정
→ 임의의 객체를 this로 지정 가능

**call 메서드**

```js
var func = function (a,b,c) {
    console.log(this, a, b, c);
};

func(1,2,3);                // window {...} 1 2 3
func.call({x:1}, 4, 5, 6);  // {x:1} 4 5 6
```


```js
var obj = {
    a: 1,
    method: function (x,y) {
        console.log(this.a, x, y);
    }
};

obj.method(2, 3);               // 1 2 3
obj.method.call({a:4}, 5, 6);   // 4 5 6
```

### 2-2. apply 메서드

- apply와 call 메서드는 기능적으로 동일
- 차이
    - call: 첫번째 인자 제외 나머지 모든 인자들을 호출할 함수의 매개변수로 지정
    - apply: 두번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정

### 2-3. call / apply 메서드의 활용 

**유사배열객체에 배열 메서드 적용**

- 객체에 배열 메서드 직접 적용 X 
- 차용 가능: 키가 0 또는 양의 정수인 프로퍼티 존재, length 프로퍼티 값이 0또는 양의 정수인 객체
- querySelectorAll 등의 Node 선택자로 선택한 결과인 NodeList도 마찬가지

- 그밖에도 유사배열객체에는 call/apply 메서드를 이용해 모든 배열 메서드 적용 가능
- 배열처럼 인덱스와 lenth 프로퍼티를 지니는 문자열도 마찬가지
! 단 문자열의 경우 lenth 프로퍼티가 읽기 전용이므로 원본 문자열 변경 메서드는 에러 

- 본래 this를 원하는 값으로 지정해 호출하는 의도와는 동떨어진 활용법
- ES6 에서는 Array.from 메서드 새로 도입

**생성자 내부에서 다른 생성자 호출**

- 생성자 내부에 다른 생성자와 공통 내용 존재 시 call, apply로 반복 감소 가능

*여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply*
- 여러 인수받는 메서드에 하나의 배열로 인수 전달을 원할 시 apply가 적합
- ex. 배열에서 최대/최솟값 구할 시 
- apply 보다 간편한 ES6의 펼치기 연산자도 존재!

    ! 명시적으로 별도의 this 바인딩 및 훌륭한 함수/메서드 실행법이지만 this 예측의 어려움으로
    코드 해석 방해 - ES5이하 환경에서는 마땅한 대안 X → 실무에서 광범위하게 사용
    ? ES6에서는 어떨까

### 2-4. bind 메서드

```js
Function.prototype.bind(this.Arg[, arg1[, arg2[, ...]]])
```

- ES5 추가 기능으로 call과 비슷하지만 즉시 호출 X
- 넘겨받은 this 및 인수들을 바탕으로 새로운 함수 반환 
- 새 함수 호출 시 인수를 넘기는 경우 기존 bind 호출 시 전달한 인수 뒤에 이어 등록

    *목적*
    - 즉 bind 메서드는 함수에 this를 미리 적용
    - 부분 적용 함수 구현 

**name 프로퍼티**

- bind 메서드 적용한 새 함수의 독특한 성질 존재 
! name 프로퍼티에 동사 bind의 수동태인 'bound'라는 접두어 붙음
- 어떤 함수의 name 프로퍼티가 'bound xxx'면 함수명이 xxx인 원본 함수에 bind 메서드 적용한 새 함수
→ 기존의 call/apply보다 코드 추적에 수월

**상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기**

- self 등의 변수 활용 우회법 → call/apply/bind 메서드로 간결처리 가능

*call vs bind*

- 콜백 함수를 인자로 받는 함수/메서드 중 this에 관여하는 함수/메서드에 대해서도 
    bind 메서드 이용 시 this 값을 사용자 입맛에 변경 가능

### 2-5. 화살표 함수의 예외사항

ES6에 새로 도입된 화살표 함수!
    - 실행 컨텍스트 생성 시 this 바인딩 과정 제외
    - 함수 내부에 this 존재 X
    - 접근 시 스코프체인상 가장 가까운 this에 접근

    - 별도의 변수로 this 우회 또는 call/apply/bind 적용 필요 X
    → 간결하고 편리

### 2-6. 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)

- 콜백 함수 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체를 인자로 지정 가능
- thisArg 값 지정 시 콜백 함수 내부에서 this 값을 원하는 대로 변경 가능
- 배열 메서드(반복 동작 수행)에 많이 포진

## 3. 정리

*명시적 this 바인딩 미존재 시 항시 성립 규칙*
    - 전역 공간에서의 this는 전역객체를 참조
    - 함수를 메서드로 호출 시 this는 메서드 호출 주체(메서드명 앞의 객체) 참조
    - 함수를 함수로 호출 시 this는 전역 객체 참조. 메서드 내부함수에서도 동일
    - 콜백 함수 내부에서의 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며,
    정의하지 않은 경우에는 전역객체 참조
    - 생성자 함수에서의 this는 생성될 인스턴스 참조

*명시적 this 바인딩*
    - call, apply 메서드는 this를 명시적으로 지정하며 함수 또는 메서드 호출
    - bind 메서드는 this 및 함수에 넘길 인수를 일부 지정해 새 함수 생성
    - 요소 순회하며 콜백함수 반복 호출 내용의 일부 메서드는 별도 인자로 this 받기도 함