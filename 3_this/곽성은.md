## <3장. this>

---

다른 객체 지향 언어에서 this는 클래스로 생성한 인스턴스 객체를 의미함. 클래스에서만 사용할 수 있기 대문에 혼란의 여지가 없거자 많지 않음.

자바스크립트에서의 this는 어디서든 사용할 수 있음. this는 함수와 메소드를 실질적으로 구분하는 거의 유일한 기능. 

상황에 따라 this가 바라보는 대상이 달라짐

→ 어떤 이유로 그렇게 되는지 파악하기 힘든 경우도 있고 예샹과 다르게 엉뚱한 대상을 바라노는 경우도 있음

→ 이러한 경우 원인을 추적하고 수정하는데 정확한 작동 방식을 이해하지 못하면 원인을 파악해서 해결할 수 없음

**따라서 자바스크립트가 상황별로 this 가 어떻게 달라지는지,** 왜 그렇게 되는지, 예상과 다른 대상을 바라보고 있을 경우 그 원인을 효과적으로 추적하는 방법 등을 살펴보자.

### 1. 상황에 따라 달라지는 this

자바스크립트에서 **this는** 기본적으로 실행 컨텍스트가 생성될 때 함께 결정됨. **= 함수를 호출할 때 결정됨**.

함수를 어떤 방식으로 호출하느냐에 따라 값이 달라지는 것.

상황별 this가 어떤 값을 보게 되는지 살펴보자.

- **전역 공간에서의 this**
    
    전역 공간에서 this는 전역 객체를 가르킴. 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문
    
    브라우저 환경에서 전역 객체는 window, Node.js 환경에서는 global
    
    전역 변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당함.
    
    ```jsx
    var a = 1;
    console.log(a); // 1
    console.log(window.a); // 1
    console.log(this.a); // 1
    ```
    
    **자바스크립트의 모든 변수는 특정 객체의 프로퍼티**로서 동작하기 때문
    
    따라서 var a = 1이나 window.a = 1이나 똑같이 동작
    
    다만 configurable 여부, 호이스팅여부만 다르게 동작. 프로퍼티가 아닌 전역변수로 할당하는 경우 delete가 동작하지 않음.
    
    → 전역변수를 선언하면 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 configurable 속성을 false로 정의함.
    
- **메서드로서 호출할 때 그 메서드 내부에서의 this**
    
    `**함수와 메소드 : 어떤 함수를 객체의 메소드로서 호출할 경우에는 메서드, 그렇지 않으면 함수로 동작**`
    
    어떤 함수를 메서드로서 호출하는 경우의 this는 **함수명 앞의 객체, 점 표기 법의 경우 점 앞에 명시된 객체**
    
- **함수로서 호출할 때 그 함수 내부에서의 this**
    
    전역 객체를 가르킴
    
    - **메서드 내부 함수에서의 this**
        
        마찬가지로 메서드 내부에 있는 함수로서 호출했는지, 메서드로서 호출했는지에 따라 this 대상이 달라짐
        
        → **this 바인딩은 주변 환경(메서드, 함수 내부 등)을 따지지 않고, 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는 지 없는 지가 관건**
        
    - **메서드의 내부 함수에서의 this를 우회하는 방법**
        
        this라는 단어가 주는 인상과는 달라짐. 호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용하게 하고 싶음.
        
        → ES5까지는 자체적으로 내부함수에 this를 상속할 방법이 없지만 우회할 방법이 있음.
        
        ```jsx
        var obj = {
          outer: function () {
            console.log(this);
        
            var innerFunc1 = function () {
              console.log(this);
            };
            innerFunc1();
        
        		**var self = this;**
        		var innerFunc2 = function () {
              console.log(self);
            };
            innerFunc2();
        	}
        };
        obj.outer();
        ```
        
        **상위 스코프의 this를 저장해서 내부 함수에서 활용함**
        
    - **this를 바인딩하지 않는 함수**
        
        ES6에서는 this를 바인딩하지 않는 화살표 함수를 새로 도입함.
        
        **화살표 함수 : 실행 컨텍스트를 생성할 떄 this 바인딩 과정 자체가 빠지게 되어 상위 스코프의 this를 그대로 활용, 우회할 필요 없음**
        
        ```jsx
        var innerFunc = function () =>{
              console.log(this);
            };
            innerFunc();
        ```
        
        그 밖에도 call, apply 등의 메서드를 활용해 함수를 호출할 때 명시적으로 this를 지정하는 방법이 있음 뒤에서 살펴볼 것
        
- **콜백 함수 호출 시 그 함수 내부에서의 this**
    
    콜백 함수는 함수이기 때문에 기본적으로 this가 전역객체를 참조하지만, 콜백 함수를 받은 함수 내부에 별도로 this가 될 대상을 지정한 경우에 그 대상을 참조하게 됨.
    
- **생성자 함수 내부에서의 this**
    
    객체지향 언어에서 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스라고 하는 것
    
    어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 **this는 곧 새로 만들 구체적인 인스턴스 자신이 됨**
    
    ```jsx
    var Cat = function (name, age) {
      this.bark = "야옹";
      this.name = name;
      this.age = age;
    };
    
    var choco = new Cat("초코", 7);
    var nabi = new Cat("나비", 5);
    
    console.log(choco); // Cat {bark: '야옹', name: '초코', age: 7};
    console.log(choco); // Cat {bark: '야옹', name: '나비', age: 5};
    ```
    

### 2. **명시적으로 this를 바인딩하는 방법**

규칙을 깨고 this에 별도의 대상을 바인딩하는 방법.

- **call 메서드**
    
    Function.prototype.call(thisArg[,arg1[,arg2[,…]]])
    
    **메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령, 임의의 객체를 this로 지정 할 수 있음**
    
    첫 번째 인자를 this로 바인딩하고 이후 이자들을 호출할 함수의 매개변수로 함
    
    ```jsx
    var func = function (a, b, c) {
      console.log(this, a, b, c);
    };
    
    func(1, 2,3 ); // Window{...} 1 2 3
    func.call({ x: 1 }, 4, 5, 6); // {x: 1} 4 5 6
    ```
    
- **apply 메서드**
    
    call 메서드와 기능적으로 동일, 다만 두번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정함
    
    ```jsx
    var func = function (a, b, c) {
      console.log(this, a, b, c);
    };
    
    func.apply({ x: 1 }, [4, 5, 6]; // {x: 1} 4 5 6
    ```
    
- **call, apply 메서드의 활용**
    - **유사배열객체에 배열 메서드를 적용**
        
        배열의 구조와 유사한 객체의 경우 call과 apply 메서드를 활용해 배열 메서드인 push로 객체에 추가하고 slice 메서드로 객체를 배열로 전환 가능, **즉 call, apply 메서드를 이용해 모든 배열 메서드 적용, 활용 가능**
        
        call과 apply를 이용해 형변환 하는 것은 본래 메서드의 의도와 동떨어진 활용법. → ES6에서는 Array, From 메서드 도입(순회 가능한 모든 종류의 데이터 타입을 배열로 전환하는 메서드)
        
    - **생성자 내부에서 다른 생성자를 호출**
        
        생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call, apply를 이용해 호출하면 반복 줄일 수 있음
        
    - **여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply**
        
        여러 개 의 인수를 받는 메서드에서 하나의 배열로 인수들을 전달하고 싶을 때 사용
        
        배열로 묶어 놓고 전달하면 간단해짐
        
- **bind 메서드**
    
    call과 비슷하지만 즉시 호출하지는 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드
    
    **→ 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적**
    
    ```jsx
    var func = function (a, b, c, d) {
      console.log(this, a, b, c, d);
    };
    
    func(1, 2, 3, 4); // Window{...} 1 2 3 4
    
    var bindFunc1 = func.bind({ x: 1 });
    bindFunc1(4, 5, 6, 7); // {x: 1} 4 5 6 7
    
    var bindFunc2 = func.bind({ x: 1 }, 7, 8);
    bindFunc3(9, 10); // {x: 1} 7 8 9 10
    ```
    
    - **name 프로퍼티**
        
        bind 메서드를 적용해서 새로 만든 함수에 name 프로퍼티에는 bound라는 접두어가 붙음
        
    - **상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기**
        
        내부 함수에서 this를 self 등의 변수로 우회해서 사용하지 않고 call, apply, bind 메서드로 깔끔하게 처리 가능
        
- **화살표 함수**
- **별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)**
    
    콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체(thisArg)를 인자로 지정할 수 잇는 경우가 있음. 이러한 메서드의 thisArg 값을 지정하면 콜백 함수 내부에서 this 값을 원하는 대로 변경 가능
    
    → 배열 메서드에 많이 있음. Set, Map, forEach 등
    
    `Array.prototype.forEach(callback[, thisArg])`