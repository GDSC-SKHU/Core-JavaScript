## 03 this

자바스크립트에서의 this는 어디서든 사용할 수 있음

상황에 따라 this가 바라보는 대상이 달라짐

함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능

### 3-1 상황에 따라 달라지는 this

this는 함수를 호출할 때 결정된다고 할 수 있음, 함수를 어떤 방식으로 호출하느냐에 따라 값이 달라지는 것

- 3-1-1 전역 공간에서의 this

  - 전역공간에서의 this

    전역 공간에서 this는 전역 객체를 가리킴

    전역객체 = 전역컨텍스트를 생성하는 주체

    브라우저 환경에서 전역객체는 window, Node.js 환경에서는 global

  - 전역변수와 전역객체

    자바스크립트의 모든 변수는 실은 특정객체의 프로퍼티로서 동작

    전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당

    전역 공간에서는 var로 변수를 선언하는 대신 window의 프로퍼티에 직접 할당하더라도 결과적으로 var로 선언한 것과 똑같이 작동

    ```js
    var a = 1;
    vindow.b = 2;
    c = 4;
    console.log(a, window.a, this.a); /// 1 1 1
    console.log(b, window.b, this.b); /// 2 2 2
    console.log(c, window.c, this.c); /// 4 4 4
    ```

    전역변수 선언과 전역객체의 프로퍼티 할당 사ㅣ에 전혀 다른 경우도 있음

    '삭제'명령에 대해 그럼

    -> 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 configurable(변경 및 삭제 가능성) 속성을 false로 정의

    -> var로 선언한 전역변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable 여부에서 차이를 보임

- 3-1-2 메서드로서 호출할 때 그 메서드 내부에서의 this

  - 함수를 실행하는 방법

    1. 함수로 호출하는 경우

    2. 메서드로서 호출하는 경우

    _독립성_

    함수는 그자체로 독립적인 기능을 수행

    메서드는 자신을 호출한 대상 객체에 관한 동작을 수행

    **어떤 함수를 호출할 때 그 함수 이름(프로퍼티명) 앞에 객체가 명시돼 있는 경우에는 메서드로 호출한 것이고, 그렇지 않은 모든 경우에는 함수로 호출한 것**

    점 표기법과 대괄호 표기법으로 함수 호출

    ```js
    var obj = {
      method: function (x) {
        console.log(this, x);
      },
    };
    obj.method(1); //{ method: f } 1
    obj["method"](2); //{method: f} 2
    ```

  - 메서드 내부에서의 this

    this에는 호출한 주체에 대한 정보가 담김

    어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체임

    점 표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this

    ```js
    var obj = {
      methodA: function () {
        console.log(this);
      },
      inner: {
        methodB: function () {
          console.log(this);
        },
      },
    };

    obj.methodB(); /// obj
    obj.inner.methodB(); /// obj.inner
    ```

- 3-1-3 함수로서 호출할 때 그 함수 내부에서의 this

  - 함수 내부에서의 this

    2장에서 실행 컨텍스트를 활성화할 당시에 this가 지정되지 않은 경우 함수에서의 this는 전역 객체를 가리킴

    -> 더글라스 크락포드는 이를 명백한 설계상의 오류라고 지적함

  - 메서드의 내부함수에서의 this

    this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고, 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호

    표기가 있는지 없는지가 관건

  - 메서드의 내부 함수에서의 this를 우회하는 방법

    호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this의 대상이 서로 달라지는 것

    현재 컨텍스트에 바인딩된 대상이 없으면 직전 컨텍스트의 this를 바라보도록 하고 싶음

  -> 우회하는 방법 = 변수를 활용하는 것

  ```js
  var obj = {
    outer: function () {
      console.log(this);
      var innerFunc1 = function () {
        console.log(this);
      };

      innerFunc1();

      var self = this;
      var innerFunc2 = function () {
        console.log(self);
      };
      innerFunc2();
    },
  };
  obj.outer();
  ```

- this를 바인딩하지 않는 함수(화살표 함수)

  화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있음

  그 밖에도 call, apply 등의 메서드를 활용해 함수를 호출할 때 명시적으로 this를 지정하는 방법도 있음

- 3-1-4 콜백 함수 호출 시 그 함수 내부에서의 this

  함수 A의 제어권을 다른 함수(또는 메서드) B에게 넘겨주는 경우 함수 A를 콜백 함수라고 함

  콜백 함수도 함수이기 때문에 기본적으로 this가 전역객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정함

  addEventListener 메서드는 콜백 함수를 호출할 때 자신의 this를 상속하도록 정의돼 있음 -> 메서드명의 점(.) 앞부분이 곧 this가 됨

  콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지는 결정하며, 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역객체를 바라봄

- 3-1-5 생성자 함수 내부에서의 this

  생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수

  객체지향 언어에서는 생성자를 클래스(class), 클래스를 통해 만든 객체를 인스턴스(instance)라고 함

  자바스크립트는 함수에 생성자로서의 역할을 함께 부여

  new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작

  **어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 됨**

### 3-2 명시적으로 this를 바인딩하는 방법

this에 별도의 대상을 바인딩하는 방법

- 3-2-1 call 메서드

  call 메서드의 첫 번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 함

  ```js
  var func = function (a, b, c) {
    console.log(this, a, b, c);
  };

  func.call({ x: 1 }, 4, 5, 6); // {x: 1} 4 5 6
  ```

  메서드에 대해서도 마찬가지로 객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this롤 지정 가능
  능

- 3-2-2 apply 메서드

  call 메서드와 기능적으로 완전히 동일

  두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변서로 지정

- 3-2-3 call / apply 메서드의 활용

  키가 0 또는 양의 정수인 프로퍼티가 존재하고 length 프로퍼티의 값이 () 또는 양의 정수인 객처,

  즉 배열의 구조와 유사한 객체의 경우(유사배열객체) call 또는 apply 메서드를 이용해 배열 메서드를 차용할 수 있음

  querySelectorAll, getElementsByClassName 등의 Node 선택자로 선택한 결과인 NodeList도 마찬가지 임

  그 밖에도 유사배열객체에는 call/apply 메서드를 이용해 모든 배열 메서드를 적용할 수 있음

  배열처럼 인덱스와 length 프로퍼티를 지니는 문자열도 가능

  그러나 문자열의 경우 length 프로퍼티가 읽기 전용이기 때문에 원본 문자열에 변경을 가하는 메서드는 에러를 던지며,

  concat처럼 대상이 반드시 배열이어야 하는 경우에는 에러는 안 나지만 제대로 된 결과를 얻을 수 없음

  Array.from은 유사배열객체 똔느 순회 가능한 모든 종류의 데이터탑을배열로 전환하는 메서드

  생성자 내부에서 다른 생성자 호출

  생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call 또는 apply를 이용

  여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용

- 3-2-4 bind 메서드

  즉시 호출하지는 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드

  목적

  1. 함수에 this를 미리 적용하는 것

  2. 부분 적용 함수를 구현하는 것

  name 프로퍼티

  name 프로퍼티에 동사 bind의 수동태인 'bound'라는 접두어가 붙음

  -> 어떤 함수의 name 프로퍼티가 'bound xxx'라면 이는 곧 함수명이 xxx인 원본 함수에 bind 메서드를 적용한 새로운 함수라는 의미

  -> 코드 추적 수월

  상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달

  내부함수에 call, bindf를 활용해서 전달

  콜백 함수를 인자로 받는 함수나 메서드 중에서 기본적으로 콜백 함수 내에서의 this에 관여하는 함수 또는

  메서드에 대해서도 bind 메서드를 이용하면 this 값을 사용자의 입맛에 맞게 바꿀 수 있음

- 3-2-5 화살표 함수와 예외사항

  this에 접근하고자 하면 스코프체인상 가장 가까운 this에 접근하게 됨

  this를 위화하거나 call/apply/bind를 적용할 필요 없음

- 3-2-6 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)

  콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 저장할 객체(thisArg)를 인자로 지정할 수있는 경우가 있음

  이러한 메서드의 thisArg 값을 지정하면 콜백 함수 내부에서 this 값을 원하는 대로 변경 가능
