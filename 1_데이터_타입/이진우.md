# 데이터 타입

## 1-1 데이터 타입의 종류
### 기본형(원시형 Primitive type)
 - 숫자: number
 - 문자열: string
 - 불리언: boolean
 - null
 - undefined
 - 심볼: symbol (ES6에 추가됨)

### 참조형(reference type)
 - 객체: object
   - 배열: Array
   - 함수: Function
   - 날짜: Date
   - 정규표현식: RegExp

// ES6에서 추가된내용
 - Map
 - WeakMap
 - Set
 - WeakSet


> Q . 기본형과 참조형의 공통점은? </br>
> A .  둘 다 주소값을 복제 해온다.
> </br>
> </br>
> Q . 기본형과 참조형을 구분하는 기준은? </br>
> A . 기본형: 값이 담긴 주솟값을 바로 복제</br>
> 참조형: 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제

기본형은 불변성(immutable)하다.

---
</br>
</br>

## 1-2 데이터 타입에 관한 배경지식
### 메모리와 데이터
- 비트(bit): 0,1만 표현할 수 있는 하나의 메모리 조각
- 각 비트는 고유한 식별자(unique identifier)을 통해 위치 확인 가능
- 조금 더 정확하게는 **메모리 주솟값**(memory address)을 통해서 서로 구분하고 연결함
- 데이터의 효율적인 관리를 위해 적절한 단위의 묶음인 byte등장
- 1byte = 8bit = 2^8 = 256
- 2byte = 16bit = 2^16 = 65536
- c/c++, java 등의 정적 타입 언어는 메모리낭비를 최소화 하기 위해 타입별로 할당할 메모리영역을 2byte, 4byte 등으로 미리 정해둠 

_메모리 용량이 과거에 비해 월등히 많아진 지금은 메모리 압박에서 좀 자유로워짐_
> js : 숫자의 경우 부동소수점? 정수형? 걍 다 8byte 공간줄게! 

</br>

### 식별자와 변수
변수(variable) : 변할 수 있는 무언가(**데이터**)</br>
식별자(identifier) : 데이터를 식별할때 쓸 이름(**변수명**)</br>
보통 둘이 헷갈림 ㅇㅇ</br>

---
</br>
</br>

## 1-3 변수 선언과 데이터 할당
```js
// 변수 선언
var a;
```
> **변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다.**

변수 : 데이터가 담길 그릇, 공간

```js
// 변수 선언과 할당
var a;          // 변수 a 선언
a = 'abc';      // 변수 a 에 데이터 할당

var a = 'abc';  // 변수 선언과 할당을 한 문장으로 표현
```
> 변수 선언과 데이터 할당에 대한 메모리 영역의 동작 방식
> 1. 변수 영역에서 빈 공간(@1003)을 확보한다.
> 2. 확보한 공간의 식별자를 a로 지정한다.
> 3. 데이터 영역의 빈공간 (@5004)에 문자열 'abc'를 저장한다.
> 4. 변수 영역에서 a 라는 식별자를 검색한다(@1003).
> 5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다.

</br>**공간확보 크기** </br>
숫자형: 8byte의 공간을 확보</br>
문자열: 주어지는 크기에 맞게 (가변적)</br>
1글자당 영어:1bit / 한글: 2bit  
</br>

**데이터 관리**
```
미리 만들어 둔 abc라는 문자열의 크기를 늘리려면 뒤의 데이터 공간을 늘려야 하는 상황이 무조건 생긴다. 
-> 그러면 얼마나 더 밀어야하지? 너무 비효율 적이잖아!

그래서 걍 새로 데이터를 선언함 ㅇㅇ
abc를 만들었어? 어쩌라고 abcdef 새로 만들거임~

그 결과: 문자열은 어떠한 변화가 생기면 무조건 새로 만들어서 저장한다~

하지만 이거 좀 비효율적인거 같아요~ㅠㅠ
??? 자 예시를 보자

500개의 변수를 생성해서 다 5를 할당하는 상황을 가정하자.
500개에 숫자형은 8바이트니 총4000(500*8)바이트를 써야한다. 맞제?

하지만! 그 5를 별도의 공간에 저장한다면? 그 공간이 2바이트짜리라면!
단 1008(500*2+8)바이트만 쓰면 된다~

훨씬 효율이다 이거야!
```
 _그러면 식별자랑 변수를 최대한 적게 만드는게 메모리적으로는 좋지않을까?_  

---


</br>
</br>

## 1-4 기본형 데이터와 참조형 데이터
### 불변값
**기본형 데이터**인 숫자, 문자열, boolean, null undefined, symbol은 모두 **불변값**이다.</br>

**변수**와 **상수**의 차이점은 선언한 값의 **변경 가능성**이다.</br>
바뀌면 변수, 안바뀌면 상수 / 변경가능성의 **대상**은 **변수영역** 메모리</br>

**불변성의 여부**를 구분할 때의 변경가능성의 **대상**은 **데이터영역** 메모리이다.

**불변성**
```js
var a = 'abc';  // 변수 a 선언 및 데이터 할당
a = a + 'def';  // 변수 a에 새로운 데이터 'abcdef' 할당
// 'abc', 'abcdef'가 데이터 영역에 저장됨

var b = 5;      // 변수 b 선언 및 데이터 할당
var c = 5;      // 변수 c 선언 및 기존 데이터 할당
b = 7;          // 변수 b에 기존데이터 검색 후 없을시 새 데이터 저장 및 할당

// 불변성 특) 없어? 만들어 
// 나에게 [변경]은 [생성]이다.
// 가비지 컬렉팅을 당하지 않는 이상 데이터에 저장된 값은 [영원]하다.
```

**가변값** 
</br>
기본형 데이터가 불변값이야? 그럼 참조가 가변이겠네ㅋㅋ (라고 써있음)</br>
보통 맞긴한데 참조값도 불변인 경우가 있다.
</br></br>

**참조형 데이터의 할당**
```js
var obj1 = {
    a : 1,
    b : 'bbb',
};
```
> 1. 컴퓨터는 우선 변수 영역의 빈 공간 (@1002)을 확보하고, 그 주소의 이름을 obj1로 지정합니다.
> 2. 임의의 데이터 저장공간 (@5001)에 데이터를 저장하려고 보니 여러개의 프로퍼티로 이뤄진 데이터 그룹입니다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(@7103~?)를 @5001에 저장합니다.
> 3. @7103및 @7104에 각각 a 와 b라는 프로퍼티 이름을 지정합니다.
> 4. 데이터 영역에서 숫자 1을 검색합니다. 검색결과가 없으므로 임의로 @5003에 저장하고, 이 주소를 @7103에 저장합니다. 문자열 'bbb'역시 임의로 @5004에 저장하고, 이 주소를 @7104에 저장합니다.

</br>

**참조형 데이터의 프로퍼티 재할당**
```js
var obj1 = {
    a : 1,
    b : 'bbb',
};
obj1.a = 2;
```
>이 때 obj1의 변수영역의 데이터 주소는 변하지 않았다.</br>
그러나 데이터영역에서 가리키는 주소의 값이 가리키는 객체의 데이터값은 변경이 되었다.</br>
그래서 내부의 값이 바뀌었지만 변수의 데이터주소가 변하지 않았기 때문에 이건 가변성이라고 할 수 있다.</br>
</br>
??? : 나에게 [변경]이란 [생성]이다.
</br> 변경했는데 생성 안됐잖슴! 너 불변아님

</br>

**중첩된 참조형 데이터(객체)의 프로퍼티 할당**
```js
var obj = {
    x : 3,
    arr : [3,4,5]
};
```
> 1. 컴퓨터는 우선 변수 영역의 빈공간(@1002)을 확보학, 그 주소의 이름을 obj로 지정합니다.
> 2. 임의의 데이터 저장공간(@5001)에 데이터를 저장하려는데, 이 데이터는 여러개의 변수와 값들을 모아놓은 그룹(객체)입니다. 이 그룹의 각 변수(프로퍼티)들을 저장하기 위해 별도의 변수 영역을 마련하고 (@7103~?), 그 영역의 주소를 @5001에 저장합니다.
> 3. @7103에 이름x를, @7104에 이름 arr를 지정합니다.
> 4. 데이터 영역에서 숫자 3을 검색합니다. 없으므로 임의로 @5002에 저장하고, 이 주소를 @7103에 저장합니다.
> 5. @7104에 저장할 값은 배열로서 역시 데이터 그룹입니다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고 (@8104~?)를 @5003에 저장한 다음, @5003을 @7104에 저장합니다.
> 6. 배열의 요소가 총 3개이므로 3개의 변수공간을 확보하고 각각 인덱스를 부여합니다.(0,1,2)
> 7. 데이터 영역에서 숫자 3을 검색해서 (@5002) 그 주소를 @8104에 저장합니다.
> 8. 데이터 영역에서 숫자 4가 없으므로 @5004에 저장하고, 이 주소를 @8105에 저장합니다.
> 9. 데이터 영역에서 숫자 5가 없으므로 @5005에 저장하고, 이 주소를 @8106에 저장합니다.

</br>

### 변수 복사 비교
```js
var a = 10;                 // 둘 다 같은 주소값을 가짐
var b = a;                  //

var obj1 = {c:10, d:'ddd'}; // 둘 다 같은 주소값을 가짐
var obj2 = obj1;            // 
```
> - 어떤 데이터이든 변수에 할당을 하기 위해서는 주솟값을 복사해야함

*모든 데이터 타입은 참조형이나 기본형은 참조를 1번 참조형은 한번 더 한다.*

</br>

참조형 데이터의 '가변'은 [내부]의 프로퍼티를 [변경]할 때만 성립한다.

---
</br>
</br>

## 1-5 불변 객체(immutable object)

- 매번 프로퍼티가 변경될 때마다 객체를 선언하면 된다.
- 언제쓰는데? 객체내부가 변경되어도 원본 객체의 유지가 필요할 때.

</br>

```js
var user = {
    name: 'jinwoo',
    urls: {
        portifolio: 'http://github.com',
        blog: 'http://blog.com',
        facebook: 'http://facebook.com'
    }
};
// 위와같은 객체의 복사를 araboja
```
### 얕은 복사
- 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사하는 복사 </br>
- 즉, 객체의 데이터 주솟값만 복사함
- 한번만 복사하기 때문에 그 하위 객체에서는 원본이 변경되면 사본도 변경됨
- name값을 변경시에는 둘 다 다른값이지만 urls를 변경하면 원본과 사본이 둘 다 바뀐다.</br></br>

- copyObject(); 이거쓰면 얕은 복사 가능임 ㅇㅇ
- for in 문법사용해서 객체 안의 내용을 하나하나 복사해서 객체선언하는 방식임
</br></br>

### 깊은 복사
 - 객체안에 객체가 있어도 싹다 찾아서 복사함
 - name값을 변경하던 urls를 변경하던 원본 객체에 영향이 없다.
  </br></br>
 - copyObjectDeep();
 - 내부의 프로퍼티를 재귀적으로 호출해서 복사하는 방식
  </br></br>
 - 간단한 방법: JSON문자열려 변환했다가 JSON객체로 변환
 - 단점: geter/seter이나 함수, 숨겨진 프로퍼티인 __ proto __같은 애들은 인식못하고 무시함.
 - 순수한 정보만 다룰 때 사용하면 좋음

---
</br>
</br>

## 1-6 undefined와 null
- js가 값이 없는것을 나타내는것은 undefined와 null

**js가 자동으로 undefined를 부여하는 경우**
> 1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 떄
> 2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할때
> 3. return문이 없거나 호출되지 않는 함수의 실행 결과

- literal(리터럴): 메모리위치안에 저장되는 값
- empty(비어있는 요소): 순회와 관련된 많은 배열 메소드들의 순회 대상에서 제외됨
- empty는 배열내에 값을 지정하지 않았을 때 지정이 됨

**사용자가 지정하는 undefined와 js가 지정하는 undefined의 차이**
> - 사용자가 지정하는 경우: 프로퍼티(고유의 키값)이 존재하나 값이 존재 X </br>
> - js가 자동으로 지정하는 경우: 프로퍼티도없고 갑도 없음/</br> 있었는데? 아뇨 없어요 아 있는데? 없어요
> - 아니 그럼 이 차이를 어케아는데!! 헷갈리잖슴!!
> - 그니까 값이 없는걸로 지정하고 싶으면 null 쓰셈 같은 말이잖슴

</br>

*참고로 null과 undefined 둘 다 object 타입이기 때문에 값을 확인하고 싶다면 동등연산자(==)가 아니라 일치연산자(===)이거 써야됨 ㅇㅅㅇ </br>그래야 정확한 값을 얻을 수 있음* 


---
</br>
</br>

## 1-7 정리

1. js의 **데이터 타입**에는 크게 2가지 타입이 있다. **기본형**, **참조형** </br></br>
2. **변수**는 변할 수 있는 데이터가 담기는 공간이고 **식별자**는 그 이름을 뜻함</br></br>
3. 변수를 선언하면 컴퓨터는 우선 메모리의 빈공간에 식별자를 저장 그 공간에는 자동으로 undefined를 할당. 이후 데이터를 넣는것은 별도의 데이터 공간에 데이터를 저장하고 그 공간의 주소를 변수의 값 영역에 할당한다.</br></br>
4. 참조형 데이터를 할당할때는 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 별도로 확보해서 확보된 주소를 변수에 연결하고, 다시 앞서 확보한 변소 영역에 각 프로퍼티의 식별자를 저장하고, 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭시킨다. 왜? 여려개의 프로퍼티(변수)를 모은 '그룹'이기 때문에.</br> 그리고 이 차이 때문에 참조형 데이터를 '가변값'으로 여겨야한 하는 상황이 발생한다.</br></br>
5. 참조형 데이터를 '가변값'으로 여겨야 하는 상황에서도 '불변값'으로 취급하고 싶으면 내부 프로퍼티를 일일히 다 복사해 주면 된다(깊은 복사 </br>그거싫으면 라이브러리 쓰던가ㅋㅋ </br></br>
6. '없음'을 나타내는 방법에는 null과 undefined가 있다.</br> js는 값이 없거나 프로퍼티가 없거나하면 undefined를 쓴다.</br> 값이 없다고 표시하고 싶으면 null써라.
 ---