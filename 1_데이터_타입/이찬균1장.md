# 1장. 데이터 타입

---

## 01. 데이터 타입의 종류

자바스크립트 데이터 타입은 1) 기본형과 2)참조형으로 구분

| 기본형    |       참조형 |
| :-------- | -----------: |
| Number    |        Array |
| String    |     Function |
| Boolean   |         Date |
| null      |       RegExp |
| undefined | Map, WeakMap |
| symbol    | Set, WeakSet |

<br><br>

## 02. 데이터 타입에 관한 배경지식

**1-2-1. 메모리와 데이터**
JS 등장 시기 상, 메모리 관리에 대한 압박이 덜 했다. 숫자의 경우 정수형인지 부동소수형인지를 구분하지 않고 8바이트(64비트)를 확보한다.

**1-2-2. 식별자와 변수**
변수: 변할 수 있는 수 -> 데이터를 의미
식별자: 데이터를 식별하는 데 사용하는 이름 -> 변수명
<br><br>

## 03. 변수 선언과 데이터 할당

**선언**
`var a;` : 변할 수 있는 데이터를 만든다. 이데이터의 식별자는 a로 한다.
-> 선언할 때는 undefined이더라도 나중에 다른 값으로 바꿀 수 있다.

**할당**

```
var a;
a = 'abc';

var a = 'abc';

// 자바스크립트 엔진은 같은 동작을 수행
```

**선언 할당 과정**
<img src="./선언할당.png" width="600" height="150">

1. 변수 영역에서 빈 공간(@1003)을 확보
2. 확보한 공간의 식별자를 a로 지정
3. 데이터 영역의 빈 공간(@5004)에 문지얄 'abc'를 저장
4. 변수 영역에서 a라는 식별자를 검색 (@1003)
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입

참고) 문자열의 경우, 어떤 변환을 가하든 상관 없이 무조건 데이터 영역에 새로 만들어 별도의 공간에 저장한다.

**Q. 변수 영역에 값을 직접 대입하지 않고 한 단계를 더 거치는 이유는?**
A. 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 효율적으로 관리하기 위해

ex) 500개의 변수를 생성하여 모든 변수에 숫자 5를 할당하는 상황
<br><br>

## 04. 기본형 데이터와 참조형 데이터

**불변값**

- 기본형 데이터인 Number, String, Boolean, null, undefined, symbol은 모두 불변값
- 변경은 새로 만드는 동작을 통해서만 이루어진다
- 한 번 만들어진 값은 가비지 컬랙팅을 당하지 않는 한 영원히 변하지 않는다

> 변수와 상수를 구분 짖는 변경 가능성의 대상은 '변수 영역' 메모리
> 불변성 여부를 구분할 때의 변경 가능성의 대상은 '데이터 영역' 메모리

**가변값**

- 기본적인 성질은 가변값인 경우가 많지만, 설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방안도 있다.
- 기본형 데이터와의 차이는 **객체의 변수 영역**이 별도로 존재
- **데이터 영역**은 기존의 메모르 공간을 그대로 활용
- 객체 변수 영역의 변수에는 다른 값(주소값)을 얼마든지 대입할 수 있는데, 이 부분 때문에 참조형 데이터는 가변값으로 분류된다
- 즉, 객체 프로퍼티의 값이 바뀐다고 새로운 객체를 만드는 것이 아닌, 개존 객체의 내부 값만 바뀐다

> **가비지 컬랙터(Garbage Collector, GC)**
> 참조카운트: 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수
> 참조 카운트가 0인 메모리 주소는 GC의 수거 대상, 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 됨

**변수 복사 비교**

- 변수를 복사하는 과정은 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일
- 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에 차이가 발생

**변수 복사 이후 값 변경 결과 비교 1 - 객체 프로퍼티 변경 시**

```
var a = 10;
var b = a;
var obj1 = {c: 10, d: 'ddd'};
var obj2 = obj1;

b = 15;
obj2.c = 20; // 객체의 프로퍼티 변경
```

- b를 바꾸면 데이터의 값이 바뀐다
- obj2.c를 바꾸어도 obj의 값은 바뀌지 않는다
- 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있는 상태

> 자바스크립트의 모든 데이터 타입은 참조형 데이터
> 기본형: 주솟값을 복사하는 과정이 한번만 이루어짐
> 참조형: 한단계를 더 거치게 됨(총 2번)

**변수 복사 이후 값 변경 결과 비교 2 - 객체 자체를 변경 했을 때**

```
var a = 10;
var b = a;
var obj1 = {c: 10, d: 'ddd'};
var obj2 = obj1;

b = 15;
obj2.c {c: 20, d: 'ddd'}; // 객체 자체를 변경
```

- obj2에 새로운 객체를 할당함으로써 값을 직접 변경하눈 경우, 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2 위치에 저장된다
- 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경하는 경우가 아니라, **그 내부의 프로퍼티를 변경할 때**만 성립된다
  <br><br>

## 05. 불변 객체

**불변 객체를 만드는 간단한 방법**

- 내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정한다

  - changeName 함수가 새로운 객체를 반환

  ```
  var user = {
    name: 'ChanGyun',
    gender: 'male'
  };
  var chageName = function (user, newName) {
    return {
      name: newName,
      gender: user.gender
    };
  };

  var user2 = changeName(user, 'Gyun');

  if(user != user2){
    console.log('유저 정보 변경') // 유저 정보 변경
  }

  console.log(user.name, user2.name); // Changyun Gyun
  console.log(user === user2); // false
  ```

- 자동으로 새로운 객체를 만드는 도구를 활용한다
  - immutable.js, baobab.js 등의 라이브러리 등장 -> 라이브러리 자체에서 불변성을 지는 별도의 데이터 타입과 그에 따른 메서드를 제공

**얕은 복사 (shallow copy)**

- 바로 아래 단계의 값만 복사
- 객체의 프로퍼티가 모두 기본형일 때는 이렇게 해도 상관 없음

**깊은 복사 (deep copy)**

- 내부의 모든 값들을 하나하나 찾아서 전부 복사
- 객체의 프로퍼티가 객체일 때 권장
- 객체의 프로퍼티가 참조형 데이터일 때마다 재귀적으로 수행해야만 깊은 복사

_객체의 깊은 복사를 수행하는 범용 함수_

```
var copyobjectDeep = function(target){
  var result = {},
  if (typeof target === 'object' && target !== null){ // typeof가 null에 대해서도 object를 반환
    for(var prop in target){
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }
  return result;
}
```

_JSON을 활용한 간단한 깊은 복사_
-> 객체를 JSON문법으로 표햔된 문자열로 전환했다가 다시 JSON 객체로 바꾼다
-> httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋은 방법

```
var copyObjectViaJSON = function (target){
  return JSON.parse(JSON.stringify(target));
};
```

<br><br>

## 06. undefined와 null

**undefined를 반환하는 경우**

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

**undefined와 배열**

- 배열 내의 '비어있는 요소'와 'undefined'를 할당한 요소는 출력결과가 다름
- '비어있는 요소'는 순회와 관련된 배열 메소드의 순회 대상에서 제외
  -> 배열도 객체, 존재하지 않는 프로퍼티에 대해 순회 x

**undefined와 null**

- '비어있음'을 명시적으로 나타내고 싶을 때는 undefined가 아닌 null 사용
- 위의 규칙을 따르면, **undefined**는 _'값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값'_ 으로서만 조재할 수 있음

**null 버그**

```
var n = null;
console.log(typeof n); // object - JS 버그임

console.log(n == undefined); // true
console.log(n == null); // true
console.log(n === undefined); // false
console.log(n === null); // ture

// null인지 undefined인지 판별시에는 동등연산자(==) x, 일치연산자(===) o
```
