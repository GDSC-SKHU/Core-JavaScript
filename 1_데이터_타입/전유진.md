# 데이터 타입

- 데이터 처리 과정을 살펴보며 기본형 타입과 참조형 타입이 다르게 동작하는 이유 이해하기!
- 데이터 타입과 관련된 중요한 개념 익히기

## 1. 데이터 타입의 종류

> 데이터 타입의 종류 - 기본형 / 참조형
- 기본형 : number, string, boolean, null, undefined 등
* ES6 이후 : symbol 추가
**기본형은 할당이나 연산시 복제**

- 참조형 : object, Array, Function, Date, RegExp 등
* ES6 이후 : Map, WeakMap, Set, WeakSet 등 추가
**참조형은 참조**

→ 두 타입 모두 복제 가능, but 기본형은 값이 담긴 주솟값 바로 복제
→ 참조형은 주솟값들로 이루어진 묶음을 가리키는 주솟값 복제 

? 기본형은 불변성을 띄는데, 10이 담긴 변수 a 에 15를 담으면 변함 -> why 불변?

## 2. 데이터 타입에 관한 배경지식

### 2-1. 메모리와 데이터

- 각 비트는 고유한 식별자로 위치 확인 가능
- 표현 개수에 제약이 따르더라도 적정한 공간을 묶기 -> byte라는 단위 생성
* 1byte는 8개의 bit로 구성
- 메모리 용량이 매우 부족했던 과거와 다르게 형변환 걱정 X
- 모든 데이터는 바이트 단위의 식별자, 정확하게는 메모리 주솟값을 통해 구분 및 연결

### 2-2. 식별자와 변수

- 변수 = "변할 수 있는 수"
- 이때 변수는 반드시 숫자일 필요 X
- 식별자: 데이터를 식별하는 데 사용하는 이름, 변수명

## 3. 변수 선언과 데이터 할당

### 3-1. 변수 선언

*동작 원리*
> var a; 
- 위는 "데이터의 식별자는 a로 한다"와 같음
- 변수는 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇!

**변수 선언 과정**

- 메모리에서 비어있는 공간 하나를 임의로 확보한 후 이름(식별자)를 a라고 지정

- 이후 사용자가 a에 접근하고자 하면 메모리에서 a라는 이름의 주소 검색 후 해당 공간에 담긴 데이터 반환

### 3-2. 데이터 할당

```js
var a = "abc";
```

→ 데이터 할당시 해당 위치에 문자열 'abc' 직접 저장 X
→ 데이터를 저장하기 위한 별도 메모리 공간 확보 후 문자열 'abc' 저장
→ 그 주소를 변수 영역에 저장

**데이터 할당 전체 흐름**

1. 변수 영역에서 빈 공간(@1003)을 확보한다.
2. 확보한 공간의 식별자를 a로 지정한다.
3. 데이터 영역의 빈 공간(@5004)에 문자열 "abc"를 저장한다.
4. 변수 영역에서 a라는 식별자를 검색한다(@1003).
5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입한다.

? 변수 영역과 데이터 영역으로 나누어 값을 저장하는 이유
→ 데이터 변환을 자유롭게 함과 동시에 메모리를 효율적으로 관리
→ 한 글자마다 영어는 1바이트, 한글은 2바이트 등으로 각 필요한 메모리 용량이 가변적

    - 효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장!

**문자열 변환에 따른 메모리 영역의 변화**

- 문자열 'abc' 마지막에 'def' 추가 시 문자열을 새로 만들어 별도의 공간에 저장
- 이후 그 주소를 변수 공간에 연결
- 반대로 'c'를 제거하려하면 또한 새로 만듦
    - 변수 영역과 데이터 영역을 분리하면 중복된 데이터에 대한 처리 효율 증가

## 4. 기본형 데이터와 참조형 데이터 

### 4-1. 불변값 

- 변수와 상수의 구분 성질은 '변경 가능성' 
- 불변값 != 상수
- 불변성 여부 구분의 대상은 '데이터 영역 메모리'
- 기본형 데이터 타입은 모두 불변값

```js
var a = "abc"; 
a = a + "def";

var b = 5;
var c = 5; 
b = 7;
```

1. 1-2번째 줄에서 문자열 'abc'할당 후 뒤에 'def'를 추가하면 기존의 'abc' 변경 X
2. 새로운 문자열 'abcdef' 작성 후 그 주소를 변수 a에 저장
**이는 완전히 별개의 데이터**

3. 4번째 줄에서는 변수 b에 숫자 5 할당 후 데이터 영역에서 5 찾기
4. 없으면 데이터 공간을 하나 만들어 저장 후 그 주소를 b에 저장
5. 5번째 줄에서는 이미 만들어놓은 값이 있으므로 주소 재활용 

6. 6번째 줄에서는 변수 b의 값을 7로 변경하기 위해 기존에 저장한 7을 찾아 재활용
7. 없으면 새로 만들어 b에 저장
**5와 7 모두 다른 값으로 변경 불가**

→ 문자열 값과 숫자 값 모두 한 번 만든 값 변경 불가 
→ 불변값의 성질 : 새로 만드는 동작을 통해서만 변경이 이루어짐
→ 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 X

### 4-2. 가변값
- 기본형 데이터 = 불변값 -> 참조형 데이터 = 가변값?
- 기본적인 성질은 가변값인 경우가 많음

```js
var obj1 = {
        a: 1,
        b: 'bbb'
};
```

1. 변수 영역의 빈 공간(@1002)를 확보하고, 그 주소의 이름을 obj1로 지정
2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니, 여러 개의 프로퍼티로 이뤄진 데이터 그룹   
    이 그룹의 내부 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고 그 영역의 주소(@7103 ~ ?)를 @5001에 저장
3. @7103 @7104에 각각 a와 b라는 프로퍼티 이름을 지정
4. 데이터 영역에서 숫자 1을 검색 > 결과가 없으니 임의로 @5003에 저장 > 이 주소를 @7103에 저장.
    마찬가지로 'bbb'도 동일한 순서로 진행

**참조형 데이터의 할당**

- 기본형 데이터와의 차이는 '객체의 변수 영역'이 별도로 존재
- 때문에 흔히 참조형 데이터는 가변값이라고 함
- 중첩 객체: 참조형 데이터의 프로퍼티에 다시 참조형 데이터를 할당 
- 참조 카운터 = 0이 되면 가비지 컬렉터의 대상

### 4-3. 변수 복사 비교

**기본형**

```js
var a = 10;
var b = a;
```

1. 변수 영역의 빈 공간 @1001를 확보하고 식별자를 a로 지정
2. 데이터 영역에서 10을 찾고, 없으므로 빈 공간 @5001에 저장
3. @5001을 @1001에 할당
4. 변수 영역의 빈 공간 @1002를 확보하고 식별자를 b로 지정
5. 식별자 a를 검색
6. @1001에 저장된 값인 @5001을 @1002에 값으로 대입

**참조형**

```js
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;
```

1. 변수 영역의 빈 공간 @1003을 확보하고 식별자를 obj1로 지정
2. 데이터 영역의 빈 공간 @5002를 확보하고 데이터 그룹이 담겨야 하기 때문에 별도의 변수 영역 @7103 ~을 확보하고 그 주소를 저장
3. @7103에는 식별자 c를, @7104에는 식별자 d를 입력
4. c에 대입할 값 10을 데이터 영역에서 검색하고 @7103에 대입
5. d에 대입할 값 'ddd'를 데이터 영역에서 검색하고 없으니 새로 만들어서 @7104에 대입
6. 변수 영역의 빈 공간 @1004를 확보하고 식별자를 obj2로 지정
7. 식별자 obj1을 검색
8. @1003에 저장된 값인 @5002를 @1004에 값으로 대입

- 복사 과정은 동일하지만 데이터 할당 과정에서 차이 존재
- 변수 복사 이후의 동작에 큰 차이 발생

```js
var a = 10;
var b = a;

var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

1. 새로운 공간 @5004에 15 저장
2. 변수 영역에서 식별자가 b인 주소 찾기 
3. 새로운 공간 @5005에 20 저장
4. @5002가 가리키는 변수 영역에서 c를 찾아 @5005 대입 

- 어떤 데이터 타입이든 변수에 할당하기 위해 주솟값을 복사해야하므로 모든 데이터 타입은 참조형 데이터
- 다만 기본형은 주솟값을 복사하는 과정이 1번만 이뤄지고 참조형은 2단계에 거쳐 이루어짐
! '기본형도 결국 주솟값을 참조한다'

→ 참조형 데이터가 '가변값'이라 할 때의 '가변'은 참조형 데이터 자체를 변경할 경우 X
→ 그 내부의 프로퍼티를 변경할 때만 성립

## 5. 불변 객체

### 5-1. 불변 객체를 만드는 간단한 방법

1. 내부 프로퍼티를 변경할 필요가 있을 때 새로운 객체를 만들어 재할당
2. 자동으로 새로운 객체를 만드는 도구 활용

? 불변 객체가 필요한 상황
→ 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우


```js
var user = {
  name: "yujin",
  gender: "female",
};

var changeName = function (user, newName) {
  var newUser = user;
  newUser.name = newName;
  return newUser;
};

var user2 = changeName(user, "Jeon");

console.log(user.name, user2.name); // Jeon Jeon
```

- 두 변수가 서로 동일

```js
var user = {
  name: "yujin",
  gender: "female",
};

var changeName = function (user, newName) {
  return {
    name: newName,
    gender: user.gender,
  };
};

var user2 = changeName(user, "Jeon");

console.log(user.name, user2.name); // yujin Jeon
```

- 새로운 객체를 반환하며 변경 전후 비교 가능
- 객체에 정보가 많을수록 입력량 증가 -> 프로퍼티 개수에 상관없이 모든 프로퍼티를 복사하는 함수 작성

### 5-2. 얕은 복사와 깊은 복사

- 얕은 복사는 바로 아래 단계의 값만 복사
- 깊은 복사는 내부의 모든 값들을 하나하나 찾아 전부 복사
- 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티 복사 시 그 주솟값만 복사
→ 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리킴(=변수 복사 비교)

**얕은 복사**

- 원본과 사본 중 어느 쪽을 바꾸더라도 다른 한 쪽의 값도 함께 바뀜
- 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터 생성
- 한 단계 더 들어간 내부 프로퍼티들은 기존 데이터를 그대로 참조
→ 불변 객체로 만들 필요 O

**깊은 복사**
- 어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해 새로운 데이터를 만들고자 할 때, 그 값이 
기본형 데이터일 경우 그대로 복사
- 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야함.
- 이 과정을 참조형 데이터가 있을 때마다 재귀적으로 수행해야 비로소 깊은 복사

+ 깊은 복사 처리 방법
> 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 변환
> 다만 메서드나 숨겨진 프로퍼티인 __proto__나 getter/setter 등과 같이 변경 불가 프로퍼티들은 무시
> httpRequest로 받은 데이터를 저장한 객체 복사시 순수한 정보만 다룰 때 활용도 b

## 6. undefined와 null

- '없음'을 뜻하는 두 가지 값
    - undefined
    - null

**undefined**

- 사용자가 명시적으로 지정 가능하지만 값 미존재 시 자동으로 부여 
    → 자바스크립트 엔진이 자동으로 부여하는 경우 
    - 사용자가 응당 어떤 값을 지정할 것이라 예상되는 상황에서 미지정 시 undefined 반환
    1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자 접근
    2. 객체 내부의 존재하지 않는 프로퍼티에 접근
    3. return 문이 없거나 호출되지 않는 함수의 실행 결과

**null**

- '비어있음'을 명시적으로 나타내고 싶을 때 사용
! 주의: typeof null이 object, 이는 자바스크립트 자체 버그
    따라서 어떤 변수의 값이 null인지 여부 판별은 다른 방식으로 접근
    - 동등연산자(==)가 아닌 일치연산자(===)를 써야만 정확히 판별 가능 


## 7. 정리 

- 자바스크립트 데이터 타입
    1. 기본형 - 불변값
    2. 참조형 - 가변값

- 변수 - 변경 가능한 데이터가 담길 수 있는 공간
- 식별자 - 그 변수의 이름

**변수 선언**

- 메모리 빈 공간에 식별자 저장 후, 그 공간에 자동으로 undefined 할당
- 이후 그 변수에 기본형 데이터 할당 시 별도의 공간에 데이터 저장 
→ 그 공간의 주소를 변수의 값 영역에 할당

**참조형 데이터 할당** 

- 내부 프로퍼티들을 위한 변수 영역을 별도로 확보 후 확보된 주소 변수에 연결
- 확보한 변수 영역에 각 프로퍼티의 식별자 저장, 각 데이터를 별도의 공간에 저장 후 식별자들과 매칭

? 할당 과정에서 기본형과 차이가 생긴 이유
→ 참조형 데이터가 여러 개의 프로퍼티(변수)를 모은 '그룹'이기 때문!
→ 이로 인해 참조형 데이터를 '가변값'으로 여겨야만 하는 상황 발생

- 참조형 데이터를 불변값으로 사용하는 방법 존재
    - 내부 프로퍼티들을 일일이 복사(깊은 복사)
    - 라이브러리 사용 

- '없음'을 나타내는 값
    - undefined: 어떤 변수에 값이 존재 X
    - null: 사용자가 명시적으로 '없음'을 표현하기 위해 대입
    *없음을 표현하기 위해 명시적으로 undefined를 대입하는 것은 지양*