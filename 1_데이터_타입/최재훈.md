# 코어 자바스크립트 Note

## 데이터 타입

## 01. 데이터 타입의 종류

> **기본형**
> : 숫자, 문자열, 불리언, null, undefined 등

기본형은 할당이나 연산시 복제된다.  
기본형은 값이 담긴 주솟값을 바로 복제하는 반면에

> **참조형**
> : 객체, 배열, 함수, 날짜, 정규표현식(RegExp), Map, Set 등

참조형은 참조된다.  
참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.

- _불변성을 이해하려면?_
  - 메모리와 데이터에 대한 지식이 필요하다.
  - **'식별자'**와 **'변수'**의 개념을 구분해야 한다.

---

## 02. 데이터 타입에 관한 배경지식

메모리는 많은 비트들로 구성이 되있고, 각 비트는 **고유한 식별자**를 통해 위치를 확인할 수 있다.

- 0이나 1만 표현하는 비트 단위가 아니라 몇 개씩 묶어 하나의 단위로 여긴다면?
  - 표현할 수 있는 값도 늘어나고
  - 동시에 검색 시간을 줄일 수도 있다.
    - _하지만 이럴 경우 동시에 낭비되는 비트가 생기기도 한다._

과거에는 사용자가 직접 형변환을 해줘야만 했는데,  
자바스크립트는 상대적으로 메모리 관리에 대한 압박이 자유로워졌음 --> 메모리 공간을 넉넉하게 할당하였음

> - '변수'와 '식별자'를 혼용하는 이유?
>   - 문맥에 따라 무엇을 말하고 하는지를 유추할 수 있기 떄문이지만
>   - 둘의 차이를 모른다면 혼란

- **변수**는 '변할 수 있는 수", "변할 수 있는 무언가"
- **식별자**는 어떤 데이터를 식별하는데 사용하는 이름, 즉 **변수명**

---

## 03. 변수 선언과 데이터 할당

기본적인 변수 선언식

```js
var a;
```

메모리에서 _비어있는 공간 하나를 확보_  
이 공간의 이름(식별자)을 _a라고 지정_  
이후에 사용자가 a에 접근할 때는? 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환함.

- "변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다."
  즉, 변수란? 결국 _변경 가능한 데이터가 담길 수 있는 공간 또는 그릇_ 이다.

변수 선언과 할당

```js
var a; // 변수 a 선언
a = "abc"; // 변수 a에 데이터 할당
var a = "abc"; // 변수 선언과 할당을 한 문장으로 표현
```

a라는 이름을 가진 주소를 검색해서 그곳에 문자열 'abc'를 할당하면 될 것 같은데

- 실제로는 해당 위치에 문자열 'abc'를 직접 저장하지는 않아요
  - 별도의 메모리 공간을 다시 확보해서 문자열 'abc'를 저장하고,
  - 그 주소를 변수 영역에 저장하는 식으로 이루어짐
    즉, 순서대로 하자면
  1. 변수 영역에 빈 공간을 확보
  2. 확보한 공간의 식별자를 a로 지정
  3. 데이터 영역의 빈 공간에 문자열 'abc'를 저장
  4. 변수 영역에서 a라는 식별자 검색
  5. 앞서 저장한 문자열의 주소를 확보한 공간에 대입
     순서로 이루어진다.

---

## 04. 기본형 데이터와 참조형 데이터

변수와 상수를 구분짓는 성질은 '변경 가능성'이다.

바꿀 수 있으면 변수, 없다면 상수!

변경 가능성의 대상은 **변수 영역** 메모리!

> 한번 데이터 할당이 이루어진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건!

반면 불변성 여부를 구분할 떄의 변경 가능성의 대상은 **데이터 영역** 메모리임

##### 예제 1-3 불변성

```js
var a = "abc";
a = a + "def";

var b = 5;
var c = 5;
b = 7;
```

2: 새로운 문자열 'abcdef'를 만들어 그 주소를 변수 a에 저장한다. -- 'abc'와 'abcdef'는 별개의 데이터

4: b에 5 할당, 데이터 영역에서 5를 찾고, 없으면 데이터 공간을 하나 만들어 저장

5: 같은 수인 5를 할당할라함, 데이터 영역에서 5를 찾는데 있으니 그 주소를 **재사용** 함

6: 변수 b의 값을 7로 바꾸자? 그럼 기존에 저장된 5 자체를 7로 바꾸는 것이 아니라, 기존에 저장했던 7을 찾아 있으면 재활용, 없다면 새로 만들어 b에 저장

즉, 5와 7 모두 다른 값으로 변경할 수 없음.

변경은 새로 만드는 동작을 통해서만 이뤄짐. 이것이 바로 _불변값의 성질_ 이다.

##### 그렇다면 참조형 데이터는?

**객체의 변수(프로퍼티) 영역**이 별도로 존재한다는 것!  
'데이터 영역'은 기존의 메모리 공간을 그대로 활용하지만 데이터 영역에 저장된 값은 모두 불변값이야~  
그러나 변수에는 다른 값 대입이 가능!!! 즉 , 이 부분 때문에 참조형 데이터는 가변값이다~ 라고 말하는 것.

만약 원래 참조하고 있던 배열 대신 문자열 'str'을 저장하려 할 때?

- 더이상 자신의 주소를 참조하는 변수가 하나도 없게 되는데, 참조 카운트가 1이었다가 0이되버림
  - 그러면 이 메모리 주소는 가비지 컬렉터의 수거 대상이 된다.
    - 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거함!
    - 이것은 새로운 값을 할당할 수 있는 빈 공간이 된다!

#### 1-4-3 변수 복사 비교 - 객체의 프로퍼티 변경 시

```js
var a = 10;
var b = a;
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

기본형 데이터를 복사한 변수 b의 값을 바꾸면 b의 데이터 값이 달라지지만  
참조형 데이터를 복사한 변수 obj2의 프로퍼티의 값을 바꾸면 obj2의 데이터 값이 달라지지 않는다?

하지만 , 이 경우는 비교 대상의 조건 자체가 달라서 서로 동작도 다를 수밖에 없다

**즉, 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1과 obj2는 여전히 같은 객체를 바라보고 있다**

> 이 결과가 바로 기본형과 참조형 데이터의 가장 큰 _차이점_ 이다.
> 기본형은 값을 복사하고 참조형은 주솟값을 복사한다? No No
> 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 한다! 엄밀히 따지면, 모든 데이터 타입은 참조형 데이터 타입일 수 밖에 없다.
> 다만 기본형은 주솟값을 복사하는 과정이 한 번!
> 참조형은 한 단계를 더 거치게 된다!
> 이런 내부원리 이해 합시다 우리?

#### 1-4-3 변수 복사 비교 - 객체 자체를 변경했을 때

```js
var a = 10;
var b = a;
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2 = { c: 20, d: "ddd" };
```

이번에는 b의 경우와 마찬가지로 obj2에도 새로운 객체를 할당하면서 값을 직접 변경함!  
그럼? 데이터 영역의 새로운 공간에 **새 객체가 저장** 되고 그 주소를 변수 영역의 **obj2 위치에** 저장  
객체에 대한 변경임에도 값이 달라짐

**즉, 참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다**

---

## 05. 불변 객체

내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하자?

자동으로 새로운 객체를 만드는 도구를 활용하자?

객체도 불변성을 확보할 수 있다!

근데~ 어떤 상황에서 불변 객체가 필요할까?  
_값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우_ 가 있다!

##### 객체의 가변성에 따른 문제점 예시

```js
var user = {
    name: 'Lee',
    gender: 'male'
};

var changeName = function(user, newName){
    var newUser = user;
    newUser.name = newName;
    return newUser;
};
// user와 user2가 서로 같게됨. 즉 원본객체도 같이 바뀜?

--> 문제점 해결
var changeName = function(user, newName){
    return{
        name: newName,
        gender: user.gender
    };
}
// 이제 user와 user2는 서로 다른 객체임

var user2 = changeName(user, 'Jung');

if(user !== user2){
    console.log('유저 정보가 변경');
}

console.log(user.name, user2.name); // Jung Jung
console.log(user === user2); // true
```

근데 이런 식은 대상 객체에 정보가 많을수록, 사용자가 입력해야 하는 고생이 있음  
이럴 때는? 모든 프로퍼티를 복사하는 함수를 만들면 좋을 것 같다~

#### 기존 정보 복사해서 새로운 객체 반환하는 함수 (얕은 복사)

```js
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};
```

요 함수를 사용해서 하면? 간단히 객체 복사하고 내용 수정하는 것이 된다.

- 또한 immutable.js, baobab.js 등의 라이브러리들이 등장
  - 불변성을 지닌 별도의 데이터 타입과 그에 따른 메서드 제공하는 라이브러리임

#### 깊은 복사

깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법!

중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다? 이것은 얕은 복사~

그럼 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리킨다. 즉, 서로 바꾸면 서로 바뀐다.

- 예를 들어, user 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면
  - 한 단계 더 들어간 urls의 내부 프로퍼티들은 **기존 데이터를 그대로 참조** 하게 됨
    - 그렇다면 이런 현상이 안일어나게 하려면 어떻게 해야될까요?
    * _user.urls_ 프로퍼티에 대해서도 불변 객체로 만들어줘야 한다.

```js
var user2 = copyObject(user);
user2.urls = copyObject(user.urls); // 요렇게 !
```

**즉, 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야 한다.**

##### 깊은 복사를 수행하는 범용 함수

```js
var copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === "object" && target != null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }
  return result;
};
```

3번째 줄에서 target이 객체인 경우, 내부 프로퍼티들을 순회하며 copyObjectDeep 함수를 재귀적으로 호출

객체가 아닌 경우는 target을 그대로 지정하게끔

객체를 복사한 다음, 원본과 사본이 서로 완전히 다른 객체를 참조하게 되어 어느 쪽의 프로퍼티를 변경하더라도 영향을 주지 않는다.

**추가로 hasOwnProperty 메서드를 활용해 프로토타입 체이닝을 통해 상속된 프로퍼티를 복사하지 않게끔 할 수도 있다**

- 복사를 처리하는 간단한 방법?
  - 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 방식
  - 단순하고 잘 동작됨
  - 다만 메서드(함수)나 숨겨진 프로퍼티인 **proto**나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시됨.
  * 즉 httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋은 방법!
  ```js
  var copyObjectViaJSON = function (target) {
    return JSON.parse(JSON.stringify(target));
  };
  ```

---

## 06. undefined와 null

- undefined
  1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
  2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
  3. return 문이 없거나 호출되지 않는 함수의 실행 결과
     자바스크립트 엔진이 직접 undefined를 할당함!

let, const에 대해서는 undefined를 할당하지 않은 채로 초기화를 마치고, 실제 변수가 평가되기 전까지는 해당 변수에 접근할 수 없다!

- null
  - 얘는 '비어있음'을 명시적으로 나타내고 싶을 떄 undefined 대신 쓰면 된다!
  * %주의할점% : typeof null은 object 라는 점 ! 이는 자바스크립트 자체 버그임.
    - typeof 대신 다른 방식으로 null인지 여부를 판별해야 함. **일치연산자 ===** 이걸 쓰자!

## 07. 총 정리

데이터 타입: 기본형, 참조형

**변수**: 변경 가능한 데이터가 담길 수 있는 공간

**식별자**: 변수의 이름

> 변수 선언하면?
> 빈 공간에 식별자 저장
> 자동으로 undefined 할당
> 그 변수에 기본형 데이터를 할당하려고 하면 별도의 공간에 데이터를 저장
> 그 공간의 주소를 변수의 값 영역에 할당

참조형 데이터를 할당하려면?

> 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 별도로 확보해서 그 주소를 변수에 연결
> 각 프로퍼티의 식별자 저장
> 각 데이터를 별도의 공간에 저장 후 그 주소를 식별자들과 매칭
> 이런 차이가 생긴 이유? 여러 개의 프로퍼티(변수)를 모은 **'그룹'**이기 때문임

- 참조형 데이터를 가변값으로 여겨야 하는 상황임에도 이를 불변 값으로 사용하는 방법?
  - 내부 프로퍼티들을 일일이 복사하면 된다(깊은 복사)
  - 혹은 라이브러리 사용

끝!!
