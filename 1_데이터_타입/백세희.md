중요한 점, 공유하고 싶은 점, 몰랐던 점

# 데이터 타입

## 1-1 데이터 타입의 종류

- ### 기본형

  - 숫자
  - 문자열
  - 불리언
  - null
  - undefined
  - 심볼

- ### 참조형
  - 객체
  - 배열
  - 함수
  - 날짜
  - 정규표현식
  - Map, WeakMap
  - set, WeakSet

기본형 - 값이 담긴 주솟값을 바로 복제

참조형 - 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제

## 1-2 데이터 타입에 관한 배경지식

- ### 메모리와 데이터

  1 바이트 = 8개의 비트

  ex) 1바이트

  1비트마다 0 또는 1의 두 가지 값을 표현할 수 있어 256(2^8)의 값 표현 가능

  **모든 데이터는 바이트 단위의 식별자(->메모리 주솟값)을 통해 서로 구분하고 연결**

- ### 식별자와 변수
  _변수_ = 변할 수 있는 무언가 (데이터)
  ###### 데이터 = 숫자, 문자열, 객체, 배열 등
  _식별자_ (변수명) = 데이터를 식별하는 데 사용하는 이름

## 1-3 변수 선언과 데이터 할당

- ### 변수 선언

  ```js
  var a; //변수 a 선언
  ```

  ✏️ 메모리에 a라는 이름을 가진 공간 생성

- ### 데이터 할당

  **변수 영역**과 **데이터 영역**이 있음.

  ```js
  var a = "abc"; //변수 a 선언과 변수 a에 데이터 할당
  ```

  ( 변수 영역에 값을 직접 대입 ❌ )

  1. 변수 영역(@1003) 빈 공간
  2. @1003에 식별자 a로 저장
  3. 데이터 영역(@5004) 문자열 "abc" 저장
  4. 변수 영역에서 a라는 식별자 검색(@1003)
  5. 문자열 주소(@5004)를 @1003에 저장

  ✏️ 변수와 데이터를 별도의 공간에 나누어 저장하는 이유 중 하나

  데이터 변환 때 데이터 영역에서 새롭게 공간을 생성한 후 식별자 공간에서 주솟값만 변경하는 것이 효율적이기 때문

## 1-4 기본형 데이터와 참조형 데이터

- ### 불변값

  기본형 데이터

  ```js
  var a = "abc";
  a = a + "def"; /// 'abcdef'를 저장한 데이터 영역 공간 생성
  var b = 5;
  var c = 5; //5가 저장된 데이터 영역 공간 재활용
  b = 7; // 7이 저장된 데이터 영역 공간 생성
  ```

  ✏️ 문자열, 숫자 한 번 만든 값을 변경할 수 없고, 새로 만드는 동작을 통해서 이루어짐

- ### 가변값

  참조형 데이터(예외적으로 설정에 따라 변경❌ 아예 불변값 활용 ⭕ )

```js
var obj1 = {
  a: 1,
  b: "bbb",
};
```

1. 변수 영역 (@1002) 공간
2. 데이터 영역(@5001)에 여러 개의 프로퍼티 이뤄진 데이터 그룹을 저장하기 위한 별도의 변수 영역(@7013~?)생성, (@5001)에 주소(@7013~?) 저장
3. @7013에 a @7014에 b 프로퍼티 이름 저장
4. **데이터 영역(@5003)에 1 저장 그리고 @7013에 주소(@5003) 저장 ('b: "bbb"'도 마찬가지)**

   ✏️가변값이라고 하는 이유가 무엇일까?

   기본형 데이터와 다르게 '객체의 변수(프로퍼티) 영역'존재

   데이터 영역에 저장된 값은 모두 불변값이지만 변수(객체의 변수 영역)에는 다른 값을 얼마든지 대입 가능하기 때문

   중첩 객체

```js
var obj = {
  x: 3,
  arr: [3, 4, 5],
};
```

1. 변수 영역(@1002)공간
2. 데이터 영역(@5001)에 객체 @5001의 변수 영역(@7013~?)주소를 저장
3. @7103에 x @7104에 arr 변수 저장
4. 'x: 3': @5002에 숫자 3을 저장하고 이 주소를 @7103에 저장
5. 'arr: [3, 4, 5]' : 데이터 그룹으로 별도의 변수 영역(@8104~?)를 @5003에 저장하고 그 주소를 @7104에 저장
6. 배열@5003의 변수 영역(@8104~?)에 3개의 변수공간 확보 후 인덱스 0,1,2 부여
7. 데이터 영역(@5002)에 숫자 3은 있으므로 @8104에 그 주소 저장
8. 숫자 4와 5는 없으므로 데이터 영역에 새로운 공간에 각각 저장 후 (@8104~?)해당 배열 변수에 저장

arr[1] 찾는 순서

@1002 -> @5001 -> (@7103~?) -> @7104 -> @5003 -> (@8104~?) -> @8015 -> @5004 -> 반환

```js
obj.arr = "str"; // @5003와 @8104~?는 GC 대상으로
```

- ### 변수 복사 비교

  변수 복사 비교

```js
var a = 10; //변수 영역(@1001)에 데이터 영역 주소(@5001) 저장
var b = a; //변수 영역(@1002)에 기존에 있는 데이터 영역 주소(@5001) 저장

var obj1 = { c: 10, d: "ddd" }; // 변수 영역(@1003)에 데이터 영역 주소(@5002) 저장/ 객체 @5002의 변수 영역(@7103~?) 어찌어찌 ~
var obj2 = obj1; // 변수 영역(@1004)에 기존에 있는 데이터 영역 주소(@5002)를 값으로 대입
```

✏️ 기본형 데이터 복사와 참조형 데이터 복사과정은 큰 차이 없음

변수 복사 이후 값 변경 결과 비교(1) - 객체의 프로퍼티 변경시

```js
b = 15;
obj2.c = 20;
```

🔽

```js
a !== b;
obj1 === abj2;
```

✏️ 값(b)을 직접 변경하여 a와 b는 변수의 값이 달라짐

    obj2.c는 내부 프로퍼티를 변경하여 obj1와 obj2는 변수 값이 달라지지 않음

변수 복사 이후 값 변경 결과 비교(2) - 객제 자체를 변경했을 때

```js
obj2.c = { c: 20, d: "ddd" };
```

🔽

```js
obj1 !== abj2;
```

✏️ obj2.c의 변경을 위해 데이터 영역의 새로운 공간에 새 객체를 저장하고 그 주소를 변수 영역의 obj2위체 저장 -> obj1와 obj2 값이 달라짐

**참조형 데이터가 '가변값'이라고 설명할 때의 '가변'은 참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립한다.**

## 1-5 불변 객체

- ### 불변 객체를 만드는 간단한 방법
  객체의 가변성에 따른 문제점의 해결 방법
  (예제 코드가 있긴 하지만 PASS)
  1. 새로운 객체 반환 -> 문제점: 새로운 객체를 만들면서 변경할 필요가 없는 기존 객체의 프로퍼티를 하드코딩으로 입력
  2. 대상 객체의 프로퍼티 개수에 상관 없이 모든 프로퍼티를 복사하는 copyobject 함수 -> 문제점: 얕은 복사
- ### 얕은 복사와 깊은 복사

  얕은 복사: 바로 아래 단계의 값만 복사

  깊은 복사: 내부의 모든 값을 하나하나 찾아서 전부 복사

  #### 깊은 복사 방법

  1. copyObject 함수

     기본형 데이터일 경우에는 그대로 복사하면 되지만 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야 함

     ```js
     var user2 = copyObject(user);
     user2.urls = copyObject(user.urls); //참조형 데이터 내부의 프로퍼티들을 복사한 것임

     user.urls.portfolio = "httl:~";
     consol.log(user.urls.portfolio === user2.urls.portfolio); //false
     ```

  2. copyObjectDeep 함수
  3. JSON 활용 (아직 이해 ❌❌❌)

## 1-6 undefined와 null

### undefined

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

##### undefined와 배열

'비어있는 요소'와 'undefined를 할당한 요소'는 출력 결과부터 다름

'비어있는 요소'는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외

### null

'비어있음'을 명시적으로 타내고 싶을 때는 undefined가 아닌 null을 쓰면 됨

## 1-7 정리

1. 데이터 타입
   
   기본형 : 기본적으로 불변값

   참조형 : 기본적으로 가변값

2. 변수와 식별자

   변수: 변경 가능한 데이터가 담길 수 있는 공간

   식별자: 그 변수의 이름

3. 변수 선언

   메모리의 빈 공간에 식별자 저장

   그 공간에 자동으로 undefined를 할당

   _**기본형 데이터 할당**_

   별도의 공간에 데이터 저장

   그 공간의 주소를 변수의 값 영역에 할당

   _**참조형 데이터 할당**_

   참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 별도로 확보

   확보된 주소를 변수에 연결

   확보한 변수 영역에 각 프로퍼티의 식별자 짱

   각 데이터를 별도의 공간에 저장해서 그 주소를 식벼자들과 매칭

  ✏️ **할당 과정에서 기본형과 차이가 생긴 이유**
  
     참조형 데이터가 여러 개의 프로퍼티(변수)를 모은 '그룹'이기 때문

4. '없음'을 나타내는 값 'undefined'와 'null'
