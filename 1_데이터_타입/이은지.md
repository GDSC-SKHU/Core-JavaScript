# 데이터 타입

## 데이터 타입의 종류
---

-기본형(Primitive type)
    -숫자(Number)
    -문자열(String)
    -불리언(boolean)
    -null
    -undefined
    -심볼(Symbol)
-참조형(Reference type)
    -객체(Object)
    -배열(Array)
    -함수(Function)
    -날짜(Date)
    -정규표현식(RegExp)
    -Map, WeakMap
    -Set, WeakSet

## 데이터 타입에 관한 배경지식
---

### 메모리와 데이터

-비트(bit): 0 또는 1만 표현할 수 있는 하나의 메모리 조각
    -각 비트는 고유한 식별자(메모리 주솟값)를 통해 **위치**를 확인할 수 있음->비효율적
-바이트(byte): 8개의 비트로 구성된 데이터 묶음
    -1바이트는 256(2의 8제곱)개의 값 표현 가능

### 식별자와 변수

-변수: 변할 수 있는 **무언가(데이터)**
-식별자(변수명): 어떤 데이터를 식별하는 데 사용하는 이름

## 변수 선언과 데이터 할당
---

### 변수 선언

> var a;
변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다.   

이렇게 변수를 선언하게 되면 한 주소에 값이 없이 이름만 들어가게 된다.   

> var a = 'abc';
이렇게 변수를 선언하게 되면 한 주소에 이름과 값이 들어가게 되는데, 값을 직접 입력하는 것이 아닌 데이터 영역에서 값을 **대입**하게 된다.   
즉 abc라는 값을 100군데에서 사용해야 한다면 그 100군데에 모두 값을 일일이 넣어주는 것이 아닌, 100군데가 한 곳을 참조한다고 보면 된다.

-이점
    -자유로운 데이터 변환
    -메모리 관리의 효율성

더 나아가, a의 값을 10으로 변경하면 한 주소에 값이 어떻게 될까?
기존에 참조하던 abc 말고 10이 들어있는 주소를 데이터 영역에서 찾아 그 주소를 참조한다. 만약 10이 들어있는 주소가 없다면 빈 주소에 10을 할당하게 된다.

## 기본형 데이터와 참조형 데이터
---

### 불변값

변경 가능성: 변수(variable)와 상수(constant)를 구분하는 성질

변수와 상수를 구분 짓는 변경 가능성의 대상: 변수 영역
불변성 여부를 구분할 때 변경 가능성의 대상: 데이터 영역

변경은 새로 만드는 동작을 통해서만 이루어짐
기본형 데이터는 모두 불변값

### 가변값

기본형 데이터와의 차이: 객체의 변수(프로퍼티) 영역이 별도로 존재


>var obj1 = {
>    a: 1,
>    b: 'bbb'
>};
>obj1.a = 2;

마지막 줄을 보면 obj1의 a의 값을 바꾸었다. 이렇게 되었을 때 변수 영역의 이름과 값은 변하지 않는다. 그러나 객체의 변수 영역의 값(참조하는 주소)이 변하는 것을 볼 수 있다.

참조 카운트가 0인 메모리 주소는 가비지 컬렉터(Garbage Colletor)의 수거 대상이 된다. GC는 특정 시점이나 메모리 사용량이 포화 상태가 될 때마다 자동으로 수거 대상들을 수거한다. 수거된 메모리는 값을 할당할 수 있는 빈 공간이 된다.

### 변수 복사 비교

변수 복사 이후 값을 변경했을 때
-객체의 프로퍼티를 변경했을 때
    -기본형 데이터: 값이 달라짐
    -참조형 데이터: 값은 같음. 그러나 객체 변수 영역의 값이 달라지게 됨

>궁금한 점
>
>obj1과 obj2 중 하나만 바꿔도 두 객체에 모두 적용이 되는지?
>아니면 obj1을 호출할 때는 10, obj2를 호출할 때는 20으로 값이 유동적으로 바뀌는 건지?

-객체 자체를 변경했을 때
    -기본형 데이터: 값이 달라짐
    -참조형 데이터: 값이 달라지고 새로운 객체 변수 영역을 만듦

## 불변 객체
---

### 불변 객체를 만드는 방법

불변 객체(immutable object)
-참조형 데이터의 가변은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립
-데이터 자체를 변경하고자 하면(새로운 데이터 할당) 기존 데이터는 변하지 않음

불변 객체를 생성하는 함수를 만드는 것도 좋지만, 모두가 그 규칙을 따르는 것은 무리가 있기에 프로퍼티 변경을 할 수 없게끔 라이브러리를 사용하는 것이 안전할 수 있다.

### 얕은 복사와 깊은 복사

얕은 복사(shallow copy): 바로 아래 단계의 값만 복사
깊은 복사(deep copy): 내부의 모든 값을 하나하나 찾아서 전부 복사

>var user = {
>    name: 'Eunji',
>    urls: {
>        portfolio: 'http://github.com/abc',
>        blog: 'http://blog.com',
>        facebook: 'http://facebook.com/abc'
>    }
>}

이런 코드가 있을 시, user2를 만들어서 얕은 복사를 한다고 가정하자.
>var user2 = copyObject(user);
>user2.name = 'Jung';
>user2.urls.portfolio = 'http://merong.com';
했을 때 얕은 복사는 name은 바꿀 수 있지만 url은 바꿔도 user와 user2 모두 바뀌는 것을 볼 수 있다.

이번에는 깊은 복사를 해보자
>var user2 = copyObject(user);
>user2.urls = copyObject(user.urls);
이러한 코드를 작성하게 되면 user2의 url 요소 중 아무거나 바꿔도 user와 독립적으로 동작하는 것을 볼 수 있다.

## undefined와 null
---

### undefined

-undefined가 나타나는 경우
    -값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
    -객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
    -return 문이 없거나 호출되지 않는 함수의 실행 결과
배열에서 '비어있는 요소'와 'undefined를 할당한 요소'는 출력 결과부터 다름->배열도 **객체**이기 때문
사용자가 명시적으로 부여한 경우와 비어있는 요소에 접근하려 할 때 반환되는 두 경우의 undefined의 의미를 구분하는 방법은 "사용자가 직접 undefined를 할당하지 않는다"라는 방법이 있다.

**사용자가 입력할 때는 undefined 대신 null을 써 주자**

-null 사용 시 주의할 점
    -typeof null이 object(js 자체 버그)
따라서 아래와 같이 코드를 작성해야 함

>var n = null;
>console.log(n === null);

동등 연산자(equality operator)X: undefined도 true로 나옴
일치 연산자(identity operator)O

## 정리
---

1. JS의 데이터 타입은 기본형(불변값)과 참조형(가변값)으로 나뉨
2. 변수와 식별자
    -변수: 변경 가능한 데이터가 담길 수 있는 **공간**
    -식별자: 그 변수의 이름
3. 변수 선언 시 컴퓨터는 메모리의 빈 공간에 식별자를 저장하고, 그 공간에 자동으로 undefined를 할당함
4. 기본형 데이터를 할당할 경우
    -별도의 공간에 데이터를 저장 후 그 공간의 주소를 변수의 값 영역에 할당함
5. 참조형 데이터를 할당할 경우
    -내부 프로퍼티를 위한 변수 영역을 별도로 확보해 그 주소를 변수에 연결함->앞서 확보한 변수 영역에 각 프로퍼티의 식별자를 저장->각 데이터를 별도의 공간에 저장해서 그 주소를 식별자와 매칭(이 때문에 참조형 데이터를 가변값으로 여김)
6. 참조형 데이터를 가변값으로 여겨야 하는 경우
    -깊은 복사(내부 프로퍼티를 일일이 복사)
    -라이브러리
7. '없음'
    -undefined: 어떤 변수에 값이 존재하지 않을 경우
    -null: 사용자가 명시적으로 '없음'을 표현하기 위해 대입한 값
8. 사용자가 undefined로 없음을 표현하는 것은 지양