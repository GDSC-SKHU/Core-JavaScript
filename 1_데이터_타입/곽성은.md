## <1장. 데이터 타입>

**기본형 Primitive type** : number, string, boolean, null, undefined, symbol(ES6) 등

**참조형 Reference type** : object, array, function, date, RegExp(정규표현식), Map, WeakMap, Set, WeakSet 등

**기본형과 참조형 구분 방법?**

→ 기본형은 값이 담긴 주솟값을 바로 복제

→ 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값을 복제

### **기본형의 불변성**을 이해해보자!

- **메모리와 데이터**
    
    C, C++, 자바 등의 정적 타입 언어는 데이터 타입별로 할당할 메모리 영역을 2바이트, 4바이트 등으로 정해놓음
    
    따라서 그 이상의 숫자를 입력하면 오류가 발생하므로 형변환해야 함. 사용자 입장에서 번거롭지만 메모리 용량이 부족했던 시절에는 어쩔 수 없었음
    
    메모리 용량이 커진 상황이기 때문에 **자바스크립트는 메모리 관리에 대한 압박에서 자유로워짐.** 
    
    숫자의 경우 64비트=8바이트를 확보, 사용자의 번거로움이 줄어듬
    
- **식별자 ? 변수 ?**
    
    변수 variable과 식별자 identifier를 혼용하는 경우가 많음.
    
    **변수** : 변할 수 있는 수 (반드시 숫자여야 하는 것 x **변할 수 있는 데이터**)
    
    **식별자** : 데이터를 식별하는 데 사용하는 이름 = **변수명**
    
- **변수 선언과 데이터 할당**
    - **변수 선언 동작 원리**
        
        **`var a;`** 로 변수 선언 → 메모리에서 비어있는 공간 하나 확보 → 공간의 이름(식별자)는 a
        
        사용자가 a에 접근하면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터 반환
        
    - **데이터 할당의 흐름**
        
        `var a = ‘abc’;`가 **실제로 a의 위치에 문자열 ‘abc’를 직접 저장하지 않는다**. 별도의 메모리 공간을 다시 확보해 문자열을 저장하고 그 주소를 변수 영역에 저장하는 식으로 이뤄짐
        
        1. 변수 영역에 빈 공간(@1003) 확보
        2. 확보한 공간의 식별자 a로 지정
        3. 데이터 영역에 빈 공간(@5004)에 문자열 ‘abc’ 저장
        4. 변수 영역에서 a라는 식별자 검색(@1003)
        5. 앞서 저장한 문자열의 주소(@5004)를 @1003의 공간에 대입
        
        **왜 값을 직접 대입하지 않고 번거롭게 하나?**
        
        → **데이터 변환을 자유롭게 할 수 있게 하고 메모리를 더욱 효율적으로 관리하기 위함.** 
        
        문자열은 필요한 용량이 가변적이기 때문에 특별히 정해진 규격이 없음. 미리 확보한 공간 내에서 데이터 변환을 할 수 있다면 데이터 크기에 맞게 늘리기 위해 데이터들을 옮기고.. 다시 연결하면서 처리해야할 연산이 많아지므로 별도의 공간에 저장
        
        문자열 ‘abc’ + ‘def’ 를 추가한다면 ‘abcdef’ 를 새로운 별도의 공간에 저장하고 그 주소를 연결함. 무조건 새로 만들어 별도에 공간에 저장함. 500개의 변수를 생성하여 숫자 5를 모두 할당하는 상황에서는 500개의 변수 공간을 확보해야 하지만 5만 별도의 공간에 한번에 저장하고 그 주소만 입력하면 중복된 데이터에 대한 효율이 높아짐
        
- **기본형 데이터와 참조형 데이터**
    - **불변값**
        
        변수와 상수를 구분하는 성질은 ‘변경 가능성’, 불변값과 상수는 다른 개념.
        
        변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리
        
        불변성 여부를 구분 짓는 변경 가능성의 대상은 **데이터 영역** 메모리
        
        기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값
        
        데이터 할당의 흐름에서 작성했던 것처럼 **변경은 새로 만드는 동작을 통해서만 이뤄짐.** 이것이 불변값의 성질. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않음
        
    - **가변값**
        
        기본형 데이터는 불변값. 참조형 데이터는 가변값일까?
        
        - **참조형 데이터의 할당 흐름**
            
            ```jsx
            var obj1 = {
            	a: 1,
            	b: 'bbb'
            };
            ```
            
            1. 변수 영역의 빈 공간(@1002)를 확보하고, 그 주소의 이름을 obj1로 지정
            2. 임의의 데이터 저장 공간(@5001)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이루어진 데이터 그룹, 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역 마련, 그 영역의 주소(@7103~?)를 @5001에 저장
            3. @7103 및 @7104에 각각 a와 b라는 프로퍼티 이름을 지정
            4. 데이터 영역에서 숫자 1을 검색하고 검색 결과가 없으므로 @5003에 저장하고, 이 주소를 @7103에 저장, 문자열 ‘bbb’ 역시 임의로 @5004에 저장하고 이 주소를 @7104에 저장
            
            기본형과 달리 ‘객체의 변수(프로퍼티) 영역’이 별도로 존재함. 하지만 ‘데이터 영역’은 기존의 메모리 공간 그대로 활용(불변값), **변수에는 다른 값을 대입할 수 있기 때문에 참조형 데이터는 불변하지 않다.** (가변값)
            
            재할당 명령을 내렸을 때도 데이터 영역에 저장하고 그 주소를 객체의 변수 영역에 저장, 이 전에 주소는 참조하는 변수가 하나도 없게 되므로(=참조 카운트 0)가비지 컬렉터의 수거 대상이 되어 특성 시점마다 수거하여 다시 새로운 값을 할당할 수 있는 빈 공간이 됨. 
            
    - **변수 복사 비교**
        
        복사는 위에 했던 것들과 똑같음. 복사 할 저장된 데이터 영역 주소를 대입. 참조형은 객체의 변수 영역 타고타고 대입 
        
        기본형과 참조형 데이터의 복사과정은 동일하지만 데이터 할당 과정에서 차이가 있기 때문에 변수 복사 이후의 동작에도 큰 차이 발생
        
        기본형은 복사 이후 값을 변경했을 때 데이터 주소 값이 바뀌지만 참조형은 바뀌지 않음 
        
        엄밀히 따지면 **자바스크립트의 모든 데이터 타입은 참조형 데이터일 수 밖에 없음. 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 되는 차이.**
        
        객체 자체를 변경하면 당연히 값이 변함. 이 경우는 가변값이라고 설명할 때 가변이 아님. 내부 프로퍼티 변경시에만 성립
        
- **불변 객체 immutable object**
    
    객체가 불변성이 필요할 때 ? 값으로 전달 받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우가 있음. 
    
    ```jsx
    var user = {
      name: "seongeun",
      gender: "female",
    };
    
    var changeName = function (user, newName) {
      var newUser = user;
      newUser.name = newName;
      return newUser;
    };
    
    var user2 = changeName(user, "hyeall");
    if (user !== user2) {
    	console.log('유저 정보가 변경되었습니다.');
    }
    console.log(user.name, user2.name);
    ```
    
    이 경우 user와 user2가 모두 같은 주소를 바라보기 때문에 name이 똑같이 hyeall 이 되므로 if 문도 통과되고 의도하는 기능이 아님. 불변하지 않음.
    
    changeName의 return 값을 새로운 객체를 반환하도록 하면 서로 다른 객체가 됨, 하지만 하드코딩이므로 보완해야 함.
    
    ```jsx
    var copyObject = function (target) {
      var result = {};
      for (var prop in target) {
        result[prop] = target[prop];
      }
      return result;
    };
    ```
    
    모든 개발자가 user 내부의 변경이 필요할 때는 무조건 이 함수를 사용하기로 한다면 user 객체가 불변 객체라고 볼 수 있지만 어려움. 시스템적으로 제약을 거는 편이 안전하다. → immutable.js, baobab.js 등의 라이브러리가 등장해서 인기를 끌고 있음
    
- **얕은 복사와 깊은 복사**
    
    위처럼(copyObject) 작성하면 객체에 대한 **얕은 복사, 바로 아래 단계의 값만 복사**가 되어 객체에 직접 속한 프로퍼티에 대해서는 복사해서 완전히 새로운 데이터가 만들어진 반면, 한 단계 더 들어간 값들은 복사가 되지 않았음
    
    **깊은 복사는 객체 내부의 모든 값들을 하나하나 찾아서 전부 복사**하는 방법
    
    ```jsx
    
     var copyObjectDeep = function (target) {
      var result = {};
      if (typeof target === "object" && target !== null) {
        for (var prop in target) {
          result[prop] = copyObjectDeep(target[prop]);
        }
      } else {
        result = target;
      }
      return result;
    };
    ```
    
    이 함수를 사용해 객체를 복사한 다음에는 원본과 사본이 서로 완전히 다른 객체를 참조하게 되어 어느 쪽의 프로퍼티를 변경하더라도 다른 쪽에 영향을 주지 않음
    
    이 방법 외에도 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 방법도 있음
    
- **undefined와 null**
    
    **undefined 가 부여되는 경우**
    
    1. 사용자가 명시적으로 부여
    2. **자바스크립트 엔진이 자동으로 부여**
        1. **값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때** 
        2. **객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때**
        3. **return 문이 없거나 호출되지 않는 함수의 실행 결과**
        
        ```jsx
        var a;
        console.log(a); // (1) 값을 대입하지 않은 변수에 접근
        
        var obj = { a: 1 };
        console.log(obj.b); // (2) 존재하지 않는 프로퍼티에 접근
        
        var func = function () {};
        var c = func();
        console.log(c); // (3) 반환 값이 없으면 undefined를 반환한 것으로 간주
        ```
        
        값을 대입하지 않은 경우에 대해 배열의 경우는 조금 특이한 동작을 함. 배열 크기를 지정하면 empty*배열 크기가 출력된다.
        
    
    **빈 요소의 배열 순회**
    
    빈 배열과 undefined를 직접 할당한 배열은 순회하는 것을 기본으로 추가적인 기능을 수행하는 메서드들에서 다른 결과를 보인다.
    
    undefined를 할당한 배열의 경우 일반적으로 알고 있는 대로 배열의 모든 요소를 순회해서 결과를 출력
    
    비어있는 요소에 대해서는 어떠한 처리도 하지 않고 건너 뜀.
    
    **값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타냄**
    
    따라서 그냥 직접 undefined를 할당하지 않고 ‘비어있음’을 명시적으로 나타내고 싶을 때는 null을 쓰자.
    
    null 사용시 type null이 object 이므로 다른 방식으로 null을 판별함. 
    
    동등 연산자(==)로 null과 undefined를 비교할 경우 서로 같다고 판단함. 일치 연산자(===) 를 사용해야 정확히 판별 가능