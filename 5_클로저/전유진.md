# 5. 클로저

## 5-1. 클로저의 의미 및 원리 이해 

클로저: 여러 함수형 프로그래밍 언어에서 등장하는 보편적 특성
- 고유 개념이 아니기 때문에 정의가 다양함
    *다양한 설명*
    - 자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수
    - 함수가 특정 스코프에 접근 가능하게 의도적으로 그 스코프에서 정의하는 것 
    - 함수 선언 시 생성되는 유효범위가 사라진 후에도 호출 가능한 함수
    - 이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수
    → "어떤 함수에서 선언한 변수를 참조하는 내부함수에서만 발생하는 현상"

    *외부 함수의 변수를 참조하는 내부 함수*

    ```js
    var outer = function () {
        var a = 1;
        var inner = function () {
            console.log(++a);
        };
        inner();
    };
    outer();
    ```

    1. outer 함수에서 변수 a 선언
    2. outer의 내부 함수인 inner 함수에서 a의 값 1만큼 증가 후 출력
    * inner 함수 내부에서는 a를 선언하지 않았기 때문에 상위 컨텍스트인 outer의 L.E에 접근해 a 찾음

    *외부 함수의 변수를 참조하는 내부 함수(클로저)*

     ```js
    var outer = function () {
        var a = 1;
        var inner = function () {
            return ++a;
        };
        return inner;
    };
    var outer2 = outer();
    console.log(outer2());      // 2
    console.log(outer2());      // 3
    ```

    1. inner 함수의 실행 컨텍스트의 environmentRecord에 수집할 정보 X
    2. outer-EnvironmentReference에는 inner 함수가 선언된 위치의 L.E가 참조 복사
    3. inner 함수는 outer 함수 내부에서 선언됐으므로 outer 함수의 L.E가 담김
    4. 스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 후 2 반환
    5. inner 함수의 실행 컨텍스트 종료

    ? inner 함수 실행 시점에 outer 함수는 이미 실행종료 상태 → how 접근
    → 가비지 컬렉터(어떤 값을 참조하는 변수가 하나라도 있다면 그 값은 수집 대상에 포함 X)
    → 클로저: "어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상
    * '외부 전달'이 곧 return만을 의미하는 것은 X

## 5-2. 클로저와 메모리 관리 

클로저 - 객체 지향과 함수형 모두를 아우르는 중요한 개념!
    - 메모리 누수의 위험으로 사용에 유의 → but 메모리 소모는 본질적 특성
    - 이를 이해하고 잘 활용하도록 노력 필요
    - 과거에는 의도치 않게 누수가 발생하는 상황들이 존재했지만 최근에는 발생하지 않거나 발견 어려움
    → 의도대로 설계한 '메모리 소모'에 대한 관리법만 파악해 적용하면 충분

    *관리방법*
    클로저 - 필요에 의해 의도적으로 함수의 지역변수를 메모리를 소모하도록 함으로써 발생
    - 필요성이 사라진 시점에서의 메모리 소모 방지 관리
    - 참조 카운트 = 0 : 식별자에 참조형이 아닌 기본형 데이터(null/undefined) 할당
    → GC가 수거하며 소모된 메모리 회수
    
## 5-3. 클로저 활용 사례

- 다양한 곳에서 광범위하게 활용!

### 5-3-1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때

**콜백 함수와 클로저**

```js
var fruits = ['apple', 'banana', 'peach'];
var $ul = document.creatElement('ul');

fruits.forEach(function (fruit) {               // (A)
    var $li = documet.createElement('li');
    $li.innerText = fruit;
    $li.addEventListener('click', alertFruit.bind(null, fruit));  // (B)
    $ul.appendChild($li);
});

document.body.appendChild($ul);
alertFruit(fruits[1]);
```

1. fruits 변수를 순회하며 li 생성
2. 각 li 클릭 시 해당 리스너에 기억된 콜백 함수 실행
3. fruits의 개수만큼 실행되며 그때마다 새로운 실행 컨텍스트 활성화
4. 함수 A의 실행 종료 여부와 무관하게 클릭 이벤트에 의해 각 컨텍스트의 B 실행 시 outerE.R이 A의 L.E 참조
→ 최소한 B 함수가 참조할 예정인 변수 fruit에 대해서는 (A)가 종료된 후에도 GC 대상에서 제외되어 계속 참조 가능

    - 4번째 줄의 forEach 메서드에 넘겨준 익명의 콜백함수는 내부에서 외부 변수 사용하지 않아 클로저 X
    - addEventListener에 넘겨준 콜백 함수에는 fruit이라는 외부 변수 참조 → 클로저 O
    * bind 메서드 활용 시 이벤트 객체가 인자로 넘어오는 순서가 바뀌는 점 및 함수 내부에서의 this가 원래의 그것과 달라짐
    → 고차함수를 활용하여 풀어내기(일반적)


### 5-3-2. 접근 권한 제어(정보 은닉)

정보 은닉: 모듈의 내부 로직에 대해 외부로의 노출 최소화로 모듈 간의 결합도 저하 및 유연성을 높이고자하는 개념
    접근 권한 
    - public(외부)
    - private(내부)
    - protected

- 변수 자체에 접근 권한 설계 X → 클로저로 함수 차원에서 public한 값과 private한 값 구분 가능(접근 권한 제어 가능)

*외부 함수의 변수를 참조하는 내부 함수(클로저)*(위와 같음)

```js
var outer = function () {
    var a = 1;
    var inner = function () {
        return ++a;
    };
    return inner;
};
var outer2 = outer();
console.log(outer2());
console.log(outer2());
```

- outer 함수 종료 시 inner 함수 반환으로 outer 함수의 지역변수인 a의 값 외부에서 리딩 가능
→ 클로저 활용 시 외부 스코프에서 함수 내부의 변수들 중 선택적으로 일부 변수 접근 권한 부여 가능(return 이용)

**closer라는 폐쇄성에 주목**

- outer 함수는 외부로부터 철저하게 격리된 공간
- 외부에서는 외부 공간에 노출돼 있는 outer라는 변수를 통해 outer 함수 실행 가능, outer 함수내부는 불가
- 외부에서는 오직 outer 함수가 return한 정보에만 접근 가능 → return 값이 외부에 정보를 제공하는 유일한 수단
- 외부에 제공하고자 하는 정보들을 모아 return하고 내부에서만 사용할 정보들은 return X → 접근 권한 제어 가능
- return한 변수들은 공개 멤버 / 이외의 변수들은 비공개 멤버

*클로저를 활용한 접근 권한*
- 함수에서 지역변수 및 내부함수 등을 생성
- 외부에 접근권한을 주고자 하는 대상들로 구성된 참조형 데이터(다수: 객체, 배열 / 하나: 함수)를 return

### 5-3-3. 부분 적용 함수 

부분 적용 함수: n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억시켰다 후에 (n-m)개의 인자를 넘기면
비로소 원래 함수의 실행 결과를 얻게 하는 함수

- this를 바인딩해야하는 점을 제외하면 앞서 살펴본 bind 메서드의 실행 결과 = 부분 적용 함수

```js
var add = function () {
    var result = 0;
    for (var  i = 0; i < arguments.lenth; i++>) {
        result += arguments[i];
    }
    return result;
};
var addPartial = add.bind(null, 1, 2, 3, 4, 5);
console.log(addPartial(6, 7, ,8, 9, 10));   // 55
```

* addPartial 함수는 인자 5개 선적용 후 추가적으로 인자 전달 시 모든 인자를 모아 원래의 함수가 실행(부분 적용 함수)
- add 함수는 this를 사용하지 않으므로 bind 메서드만으로 문제 없이 구현 
- this의 값을 변경 불가 → 메서드에선 사용 불가
- this에서 관여하지 않는 별도의 부분 적용 함수 필요(범용성 측면)

* 보통의 경우 부분 적용 함수는 "첫번째 인자에는 원본 함수를 두 번째 인자 이후부터는 미리 적용할 인자들을 전달하고
반환할 함수에서는 다시 나머지 인자들을 받아 이들을 한데 모아 원본 함수를 호출" 이정도로 충분
    - 부분 적용 함수에 넘길 인자를 반드시 앞에서부터 차례로 전달할 수밖에 없음
    → 인자들을 원하는 위치에 미리 넣어놓고 나중에는 빈 자리에 인자를 채워넣어 실행

**디바운스**

디바운스: 짧은 시간 동안 동일한 이벤트가 다발할 경우 이를 전부 처리않고 처음 또는 마지막에 발생한 이벤트에 대해 한 번만 처리
    - 프런트 엔드 성능 최적화에 큰 도움을 주는 기능 중 하나 
    
    *적용*
    - scroll
    - wheel
    - mousemove
    - resize

### 5-3-4. 커링 함수 

커링 함수: 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠 순차적으로 호출가능하게 체인 형태로 구성

    *커링 함수 vs 부분 적용 함수*
    - 커링은 한 번에 하나의 인자만 전달
    - 중간 과정상의 함수를 실행한 결과는 그다음 인자를 받기 위해 대기만 함
    - 마지막 인자가 전달되기 전까지는 원본 함수 실행 X
    - 커링 함수는 필요한 상황에 직접 만들어 쓰기 용이
    - 필요한 인자 개수만큼 함수 생성하여 계속 리턴해주다 마지막에 조합해서 리턴하면 됨
    - but 인자가 많아질수록 가독성이 떨어진다는 단점
    → ES6이후 화살표 함수 사용 가능(코드 흐름 파악 쉬움)

    커링 함수의 장점
    - 당장 필요한 정보만 받아 전달 / 필요한 정보가 들어오면 전달
    → 마지막 인자가 넘어갈 때까지 함수 실행 미룸(지연실행)

        *쓰이는 경우*
        - 원하는 시점까지 지연 후 실행할 때
        - 프로젝트 내에서 자주 쓰이는 함수의 매개변수가 항상 비슷하고 일부만 변경 시

    - 최근 여러 프레임워크나 라이브러리 등에서 광범위하게 사용됨

## 5-4. 정리

클로저: 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달 시 함수의 실행 컨텍스트가
종료된 후에도 해당 변수가 사라지지 않는 현상

    - 클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 
    메모리를 차지하지 않도록 관리해줄 필요 O

    - 이 책에서 소개할 활용 방안 외에도 다양한 곳에서 활용가능한 중요한 개념 

- 내부함수를 외부로 전달하는 방법에는 함수를 return하는 경우뿐 아니라 콜백으로 전달하는 경우 포함
    





    







