## 중요하다고 생각한 점

```
성은 : 클로저 용어만 알고있었는데 원리를 이해할 수 있었고
클로저가 현상을 말한다는 것을 알게되어서 도움이 되었다.
후반부로 갈수록 자바스크립트 코드 이해에 어려움을 겪었었다.
```

```
세희 : 클로저의 의미도 중요했고 정보 은닉도 알아두면 좋을 것 같다.
메모리 관리(참조카운터를 0)으로 만드는 것도 중요한 거 같다.
몰랐던 부분 : 커링함수, 부분 적용 함수 용어
```

```
은지 : 클로저 개념이 여러 개 나오는데, 애매모호하지만 중요하다고 생각하고,
메모리 관리에 대해서 같이 나누고 싶은 내용이고
정보은닉부분에서 자동차 객체를 만드는 부분이 나오는데 신기하면서, 이해하기 어려
웠던 것 같다.
```

```
유진 : 클로저의 의미가 다양하게 나오는데,
여러 가지 의미에서 한 가지 개념으로 특정하고 이해하는 게 중요한 거 같다.
실제로 코드가 나와있는 클로저 활용 예시, 커링 함수라고 생각했다.
클로저를 더 잘 이용하면 좋을 거 같고,
커링에 대해서도 따로 공부하면 좋겠다고 생각했다.
```

```
재훈 : 이름은 알아도 무슨 개념인지 몰랐는데, 개념에 대한 뜻을 알게되었고,
부분적용함수 부분에서 디바운스 부분이나 커링 함수 부분을 예시를 보면서 어떤식으
로 적용되는지 알 수 있었고
코드를 보면서 어떤 흐름으로 가는지 알기 위해서 코드를 많이 뜯어보았고,
개인적으로는 부분 적용 함수 개념쪽에서 헷갈리고 모르는 게 많아서, 그 부분을 공부
하면 좋겠다고 생각했다.
커링 함수 부분에서 redux 미들웨어 코드는 아예 몰랐던 부분이다.
```

```
찬균 : 읽으면서 클로저를 이해하려면 가비지 콜렉터의 동작 원리를 이해하는게 중요
하겠구나 생각했고,
가비지 콜렉터가 이번에 읽으면서 역할의 중요성을 알게 되었고,
클로저 안에 있는 내부 함수를 외부로 전달하는 방법이 3가지가 소개되었는데,
이것들을 잘 알고있으면 어떤 상황에서 클로저를 써야 하는지 잘 알 수 있겠다고 생각
했고,
클로저 활용 사례에서 코드들이 잘 안읽혀서,
대략적인 큰 단위에 대한 정리를 하였고
클로저를 활용해서 public,private를 구분할 수 있어서 신기했고,
커링 함수에서 마지막까지 전달되지 않는다면 원본 함수가 실행되지 않는 부분이 신기했다.
```

```
진우 : 처음에는 예시 코드가 이해가 안가다가, 후에 이해를 하게 되었다.
내부 함수가 외부 함수의 값을 참조하면 외부 함수가 끝나도 쓸 수 있어서 메모리를차
지 한다는 게 신기했다.
클로저를 잘 다루는 게 중요하고, 활용 부분에서 부분 적용 함수 부분은 잘 이해가 안갔다.
```

````
효중 : 후반부로 갈수록 코드가 안읽혔다.
디바운스 / 쓰로틀에 대해서 더 공부를 해야겠다고 생각했다.
```

```
혜성 : 클로저를 면접 대비해서 개념을 외우고만 있었지, 정확하게 알게 되어서 좋았다.
커링 함수가 중요하다고 생각하고, 리액트나 노드로 개발을 할 떄 자주 사용되서 중요
하고 디바운스와 쓰로틀이 면접에도 많이 나오고 개발 시에도 많이 쓰여서 중요하다.
심볼에 대해서 있는 것만 알고 있었는데, 책에서 설명을 해줘서 어렴풋이 알게되었다.
면접을 위해서라도 클로저를 꼭 정리했으면 좋겠다.
```

arguments객체가 들어있어서 읽는데 어려웠을 것 같다.

concat메서드

```js
var arr = [1, 2, 3];
console.log(arr.concat([4, 5]));
//[1,2,3,4,5]
````

```js
var partial = function () {
  var 오리지널인자 = arguments;
  var 오리지널함수 = 오리지널인자[0];
  if (typeof 오리지널함수 !== 'function') {
    throw new Error('첫번쨰 인자가 함수 아님');
  }
  return function () {
    //오리지널인자.slice(1);

    //오리지널인자는 유사배열 객체라
    //slice가 없어서 밑처럼 Array의 메서드를 쓰기 위해서 사용한다
    var 나머지인자들 = Array.prototype.slice.call(오리지널인자, 1);
    var 추가적인나머지인자들 = Array.prototype.slice.call(arguments);
    return 오리지널함수.apply(this, 나머지인자들.concat(추가적인나머지인자들));
  };
};

var add = function () {
  var result = 0;
  for (var i = 0; i < arguments.length; i++) {
    result += arguments[i];
  }
  return result;
};

var addPartial = partial(add, 1, 2, 3, 4, 5);
console.log(addPartial(6, 7, 8, 9, 10));
```

---

## 커링

onChangeEvent에 id나 key값을 넘겨줄 떄 주로 사용할 수 있음

```js
const onChangeItem = (index: number) => (e: ChangeEvent<HTMLInputElement>) => {
  setItems((prev) => {
    /*

        */
  });
};
```

---

## 디바운스와 쓰로틀

디바운스는 시간이 지나고 한번만 실행된다.

스크롤을 할 떄 , 입력을 할 떄 , 지도의 드래그가 끝났을 떄 , 등이 있을 수 있다.

디바운스는 이벤트가 여러 번 있을 때 일정 시간이 지나고 딱 한번 실행되는 거고

쓰로틀은 이벤트가 계속 있어도 정해진 시간만큼만 하는 것을 의미한다.

최적화 하는데 많은 도움을 줄 수 있다.

디바운스는 굉장히 많은 경우 쓸 수 있다.

```
깃헙에서 사람을 검색한다.
타자가 일정부분 끝났을 떄 호출을 요청할 수 있다.(디바운스)
```

---

## Flux 아키텍쳐

데이터를 한방향으로만 흐르게 하는 디자인 패턴이다.

redux saga,redux thunk 등에 적용되어있다.

redux thunk는 오픈소스를 통해 공부할 수 있음(코드가 짧다)
