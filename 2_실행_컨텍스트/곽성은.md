## <2장. 실행 컨텍스트>

---

**실행 컨텍스트 : 실행할 코드에 제공할 환경 정보를 모아놓은 객체**

자바스크립트는 어떤 **실행 컨텍스트가 활성화되는 시점**에 선언된 변수를 위로 끌어올리고(hoisting), 외부 환경 정보를 구성하고, this 값을 설정하는 등의 동작을 수행하는데, 이로 인해 다른 언어에서는 발견할 수 없는 특이한 현상들이 발생

동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보를 모아 컨텍스트를 구성하고 이를 콜 스택에 쌓아올렸다가 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드를 실행하는 식으로 전체 코드의 환경과 순서를 보장

하나의 실행 컨텍스트는 전역공간, eval() 함수, 함수 등으로 구성함

우리가 흔히 실행 컨텍스트를 구성하는 방법은 **함수를 실행**하는 것.

함수가 실행되면서 → 실행 컨텍스트가 콜 스택에 쌓임→ 한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간 현재 실행할 코드에 관여하게 되는 시점→ 실행 컨텍스트가 활성화, 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드를 실행하는 데 필요한 정보를 수집해서 실행 컨텍스트 객체에 저장

개발자가 코드를 통해 확인할 수는 없음

**실행 컨텍스트 객체에는**

- VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로 변경 사항은 반영되지 않음
- LexicalEnvironment : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.
- ThisBinding : this 식별자가 바라봐야 할 대상 객체

가 담김

다시 하나씩 살펴보자

### 1. **VariableEnvironment**

VariableEnvironment에 내용은 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지함

**VariableEnvironment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexialEnvironment를 만들고 이후에는 LexicalEnvironment가 주로 활용됨**

### 2. LexicalEnvironment

사전적 환경.

- **environmentRecord**
    
    현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장
    
    → 함수에 지정된 매개변수 식별자, 함수 자체, 변수의 식별자 등이 식별자에 해당
    
    컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 **순서대로** 수집
    
- **호이스팅**
    
    변수를 호이스팅할 때 **변수명만 끌어올리고 할당 과정은 원래 자리에 남겨둠**
    
    호이스팅이 되지 않으면 변수 선언을 나중에 하면 코드가 제대로 작동하지 않는 것.
    
    → 이 과정에서 함수 선언문과 함수 표현식의 차이가 발생한다.
    
    - **함수 선언문**
        
        **function 정의부만 존재하고 별도의 할당 명령이 없는 것** 
        
        반드시 함수명이 정의돼 있어야 함
        
        `function a() { .. }`
        
    - **함수 표현식**
        
        **function을 별도의 변수에 할당하는 것**을 말함
        
        함수명이 없어도 됨.
        
        `var b = function () { .. }` 익명 함수 표현식 (변수명이 함수명이 됨)
        
        `var c = function d () { .. }` 기명 함수 표현식
        
    
    **함수 선언문은 전체를 호이스팅하고 함수 표현식은 선언부만 호이스팅함.**
    
    함수 선언문은 혼란스러운 개념. 위험성을 가짐. 나중에 함수를 선언했을 때도 전부 호이스팅 되기 때문에 동일한 변수명에 할당할 경우 덮어씌워지면서 아예 다른 코드가 된다. 버그를 찾기도 어려움.
    
    → 함수 표현식으로 정의한다면 에러가 검출되므로 쉽게 디버깅 가능
    
- **스코프, 스코프체인, outerEnvironmentReference**
    
    **스코프 : 식별자에 대한 유효 범위**
    
    ES5까지는 전역 변수를 제외하면 오직 함수에 의해서만 스코프가 생성됨.  ES6에서는 다른 언어와 비슷해짐.
    
    **스코프 체인** : 스코프를 안에서 바깥으로 차례로 검색해나가는 것. 이것을 가능하게 하는 것이 LexicalEnvironment의 outerEnvironmentReference
    
    outerEnvironmentReference는 현재 호출된 함수가 **선언될 당시**의 LexicalEnvironment를 참조
    
    여러 스코프에서 동일한 식별자를 선언한 경우에는 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능
    
    ```jsx
    var a = 1;
    var outer = function () {
    	var inner = function () {
    		var a = 3;
    	};
    ...
    ```
    
    전역 공간에서는 전역 스코프에서 생성된 변수에만 접근할 수 있지만 그 안에 outer 함수 내부에서는 outer 및 전역 스코프에서 생성된 변수에 접근할 수 있지만 inner 스코프 내부에 생성된 변수에는 접근하지 못함. inner 함수 내부에서는 inner, outer, 전역 스코프 모두 접근 가능
    
    하지만 inner 함수 내부에 a 변수를 선언했기 때문에 전역 공간에 선언한 동일한 이름의 a 변수에는 접근할 수 없음. **= 변수 은닉화 variable shadowing**
    
- **전역 변수와 지역변수**
    
    전역 변수는 전역 스코프에서 선언한 것, **전역 공간에서 선언한 변수**
    
    지역 변수는 **함수 내부에서 선언한 변수**
    
    함수 선언문과 표현식에서 얘기했던 문제 상황이 함수가 전역 변수이기 때문. 함수 표현식으로 고치는 것보다도 지역 변수로 만들면 더 안전함. 
    

### 3. this

실행 컨텍스트의 thisBingding에는 this로 지정된 객체가 저장

실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체가 저장

그 외에는 호출하는 방법에 따라 this에 저장되는 대상이 다름. 3장에서 다룰 것