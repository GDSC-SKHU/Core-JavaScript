# 2. 실행 컨텍스트

실행 컨텍스트 - 실행할 코드에 제공할 환경 정보들을 모아놓은 객체

*실행 컨텍스트가 활성화되는 시점*
- 선언된 변수 호이스팅
- 외부 환경 정보 구성
- this 값 설정
→ 다른 언어와는 다른 특이현상 발생

## 1. 실행 컨텍스트란?

- 스택: 출입구가 하나뿐인 깊은 우물같은 데이터 구조
    - 저장 순서와 꺼낼 때 순서가 반대
    - 스택오버플로우의 스택과 동일

- 큐: 양쪽이 모두 열려있는 파이프
    - 대개 한쪽은 입력, 다른 한쪽은 출력 담당
    - 저장 순서와 꺼내는 순서 동일

**하나의 실행 컨텍스트 구성 방법**
전역 공간, eval() 함수, 함수 
대부분 함수를 실행하여 구성

1. 코드 실행 시 전역 컨텍스트가 콜 스택에 담김
2. 함수 호출 시 함수의 환경 정보 수집하여 실행 컨텍스트 생성 후 콜 스택에 담음.
이때 전역 컨텍스트와 관련된 코드를 일시중단하고 호출된 함수의 코드 순차 실행
3. 다른 함수의 실행 컨텍스트가 콜 스택 가장 위에 담기면 이전 함수 코드 실행 중단 후 그 함수의 코드 순차 진행
4. 두번째 함수의 실행이 종료되면 콜 스택에서 제거되며 이전 함수 실행 
5. 모든 함수 실행이 종료되면 전역 컨텍스트만 남아 실행 중단 지점부터 이어 실행
6. 전역 공간에 실행할 코드가 없을 시 전역 컨텍스트도 제거되며 콜 스택에 아무것도 없는 상태로 종료

→ 컨텍스트 관련 코드 실행하는 데 필요한 환경 정보 수집 후 실행 컨텍스트 객체에 저장

- VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보. 선언 시점의 LexicalEnvironment의 스냅샷으로 변경 사항 반영 X
- LexicalEnvironment: 처은에는 varible과 같지만 변경사항 실시간 반영
- ThisBinding: this 식별자가 바라봐야 할 대상 객체 

## 2. VariableEnvironment

차이 - VariableEnvironment 내용이 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷 유지
- 실행 컨텍스트 생성 시 VE에 정보 담은 후 그대로 복사해 LexicalEnvironment 생성 후 LexicalEnvironment 주 활용
- VariableEnvironment와 LexicalEnvironment 내부는 environmentRecord과 outer-EnvironmentReference로 구성
- 초기화 과정 중 사실상 동일

## 3. LexicalEnvironment

LE : 사전적인 환경 

### 3-1. environmentRecord와 호이스팅

- environmentRecord: 현재 컨텍스트 관련 코드의 식별자 정보 저장
- 코드 실행 전 해당 환경에 속한 코드의 변수명 인지(호이스팅)

*호이스팅 규칙*

```js
functioon a(x) {
    console.log(x); // (1)
    var x;  
    console.log(x); // (2)
    var x = 2; 
    console.log(x); // (3)
}
a(1);
```

*예상*
(1): 1
(2): undefined
(3): 2

*결과*
(1): 1
(2): 1
(3): 2

- var x;를 선언했으니 호이스팅되어 두번째 값도 1이 되는 것으로 보임
→ 호이스팅 개념 정확히 이해 필수 

**함수 선언문과 함수 표현식**

- 함수 선언문 : function 정의부만 존재하고 별도의 할당 명령 X
- 함수 표현식 : 정의한 function을 별도의 변수에 할당
! 함수 선언문의 경우 반드시 함수명 정의 필요한 반면, 함수 표현식 없어도 됨. 
- 일반적인 함수 표현식은 익명 함수 표현식(정의X)

- 실질적인 차이 : 함수 선언문은 전체 호이스팅, 함수 표현식은 변수 선언부만 호이스팅(함수도 하나의 값 취급) 
- 함수 표현식 : 함수를 다른 변수에 값으로써 할당한 것
- 선언 전에 호출해도 문제없이 실행(쉽게 접근 가능) 
- 읽던 순서와 다르기 때문에 혼란 야기 
- 상대적으로 함수 표현식이 함수 선언문보다 안전(원활한 협업)

### 3-2. 스코프, 스코프 체인, outer-EnvironmentReference

- 스코프: 식별자에 대한 유효범위
- 스코프 체인 : 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것
- outer-EnvironmentReference : LE의 두번째 수집 자료, 스코프 체인을 가능케 함

*스코프 체인*

- 선언 행위 발생
    - 콜 스택 상에서 어떤 실행 컨텍스트가 활성화된 상태일 때뿐

    - 여러 스코프에서 동일한 식별자 선언하는 경우 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능

- '전역 컨텍스트 -> outer 컨텍스트 -> inner 컨텍스트' 순으로 규모가 작아지는 반면 스코프 체인을 타고 접근가능한 변수의 수 증가
- 전역 공간에서는 전역 스코프에서 생성된 변수에만 접근 가능
- outer 함수 내부에서는 outer 및 전역 변수에 접근 가능하지만 inner 스코프 내부 변수 접근 불가
- inner함수 내부에서는 모두 접근 가능 

? 스코프 체인 상에 있는 변수 모두 접근 가능한 것은 X
- 변수 은닉화 : 내부 함수에서 전역 변수와 동일한 변수 선언 시 전역 공간에 선언한 동일 변수 접근 불가

**전역변수와 지역변수**

- 전역변수: 전역 스코프에서 선언한 a와 outer 둘
- 지역변수: outer 함수 내부에서 선언한 inner와 inner 함수 내부에서 선언한 a듈 
-> 전역 공간에서 선언한 변수는 전역 함수 내부는 지역

- 안정성 : 함수 선언문 < 함수 표현식 < 지역 변수 활용
! 코드 안전성을 위해 가급적 전역 변수 사용 최소화하기

## 4. This

- 실행 컨텍스트의 thisBinding에는 this로 지정된 객체 저장
- 실행 컨텍스트 활성화 당시 this 미지정 시 전역 객체 저장
- 그밖에 함수 호출법에 따라 this 저장 대상 다름

## 5. 정리

- 실행 컨텍스트 :실행할 코드에 제공할 환경 정보 모아놓은 객체 
  - 전역 컨텍스트 
- eval()
- 함수 실행에 의한 컨텍스트 
- 실행 컨텍스트는 활성화 시점에 VariableEnvironment, LexicalEnvironment, ThisBinding 정보 수집

- 실행 컨텍스트 생성 시 VariableEnvironment와 LexicalEnvironment가 동일 내용으로 구성
- LexicalEnvironment는 함수 실행 도중 변경 사항 즉시 반영, but VariableEnvironment는 초기 상태 유지
- VariableEnvironment와 LexicalEnvironment는 매개변수명, 변수 식별자, 선언한 함수의 함수명 등을 수집하는 ER와 바로 직전 컨텍스트의 LexicalEnvironment정보 참조하는 outer-EnvironmentReference로 구성

*호이스팅*
- 코드해석을 돕는 environmentRecord의 수집 과정 추상화한 개념
- 실행 컨텍스트가 관여하는 코드 집단의 최상단으로 이들을 끌어올린다고 해석
- 변수 선언과 값 할당 동시 발생 문장은 선언부만을 호이스팅
- 할당 과정이 남아 함수 선언문과 함수 표현식의 차이 발생

스코프: 변수의 유효범위
outer-EnvironmentReference : 해당 함수가 선언된 위치의 LexicalEnvironment 참조
- 코드 상 변수 접근 시 현재 컨텍스트의 LexicalEnvironment 탐색 후 발견 시 값 반환
- 미발견 시 다시 outer-EnvironmentReference에 담긴 LexicalEnvironment 탐색
- 해당 변수를 찾지 못하면 undefined 반환

전역 변수: 전역 컨텍스트의  LexicalEnvironment에 담긴 변수
- 지역변수: 그 밖의 함수에 의해 생성된 실행 컨텍스트의 변수 
- 안전한 코드 구성: 전역변수 사용 최소화!

this: 실행 컨텍스트 활성화 당시 지정된 this 저장
- 함수 호출법에 따라 값 변화, 미지정 시 전역 객체 저장
