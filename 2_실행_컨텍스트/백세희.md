## 실행 컨텍스트

- 실행 컨텍스트란?
  실행할 코드에 제공할 환경 정보들을 모아놓은 객체

### 2-1 실행 컨텍스트란?

#### 스택과 큐의 개념

- 스택
  - 출입구가 하나뿐인 깊은 우물 같은 데이터 구조
  - in: a, b, c, d /
    out: d, c, b, a
  - 스택이 넘칠 때 에러를 던짐
- 큐

  - 양쪽이 모두 열려있는 파이프 같은 데이터 구조
  - in: a, b, c, d /
    out: a, b, c, d

    ✏️ 흔히 실행 컨텍스트를 구성하는 방법은 함수를 실행하는 것

```js
// -------------------(1)
var a = 1;
function outer() {
    function inner() {
        console.log(a); // undefined
        var a = 3;
    }
    inner(); //--------(2)
    console.log(a);     //1
}

outer(); ---------------(3)
console.log(a);         //1

```

순간(1) 전역 컨텍스가 콜 스택에 담김 (전역 컨텍스트라는 개념은 일반적인 실행 컨텍스트와 특별히 다를 것이 없음)

순간(3) outer 함수 호출 -> outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담김

순간(2) inner 함수의 실행 컨텍스트가 콜 스택의 가장 위에 담김

inner함수 제거(콜 스택에서) -> outer함수 제거-> 전역 컨텍스트도 제거

### 2-2 VariableEnvironment

### 2-3 LexicalEnvironment

컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것

- 2-3-1 enviromentRecord와 호이스팅(hoisting)

  enviromentRecord에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됨 (컨텍스트 내부 전체를 처음부터 끝까지 순서대로)

  ✏️함수가 실행되기 전임에도 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 셈

  **hoisting** = '끌어올리다"

  변수 정보를 수집하는 과정을 이해하기 쉽게 해주는 가상 개념

  호이스팅 개념을 이해해보자.

  1. **매개변수와 변수에 대한 호이스팅**

  - 원본 코드

    ```js
    function a(x) {   // 수집 대상 1(매개변수)
        console.log(x); // (1)
        var = x;        // 수집 대상 2(변수 선언)
        console.log(x); // (2)
        var x = 2;      // 수집 대상 3(변수 선언)
        console.log(x); // (3)
    }
    a(1)
    ```

  - 변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨 둔다.

    ```js
    function a() {
      var x; //수집 대상 1의 변수 선언 부분
      var x; //수집 대상 2의 변수 선언 부분
      var x; //수집 대상 3의 변수 선언 부분

      x = 1; //수집 대상 1의 할당 부분
      console.log(x); //(1)
      console.log(x); //(2)
      x = 2; //수집 대상 3의 할당 부분
      console.log(x); //(3)
    }
    a();
    ```

  ✏️호이스팅 개념을 이해하면 (1)1, (2)1, (3)2 를 예측하기 수월함.

  2. **함수 선언의 호이스팅**

  - 원본 코드

    ```js
    funtion a() {
        console.log(b);  //(1)
        var b = 'bbb';   // 수집 대상 1(변수 선언)
        console.log(b);  //(2)
        function b() { } // 수집 대상 2(함수 선언)
        console.log(b);  //(3)
    }

    a();
    ```

  - 함수 선언의 호이스팅할 때 함수 선언은 전체를 끌어올림

    ```js
    funtion a() {
       var b;                       //수집 대상 1. 변수는 선언부부만 끌어올립니다.
       function b = function b() {} //수집 대상 2. 함수 선언은 전체를 끌어올립니다.

       console.log(b);              //(1)
       b = 'bbb';                   // 변수의 할당부는 원래 자리에 남겨둡니다.
       console.log(b);              //(2)
       console.log(b);              //(3)
    }

    a();
    ```

    호이스팅이 끝난 상태에서의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있어 함수 표현식으로 바꿈

    ✏️호이스팅 개념을 이해하면 (1)b 함수, (2)'bbb', (3)'bbb'

    **함수 선언문과 함수 표현식**

  - 함수 선언문: function 정의부만 존재하고 별도의 할당 명령이 없는 것

    **함수명 a가 곧 변수명**

    ```js
    function a() {
      /*...*/
    }

    a(); // 실행 OK.
    ```

  - 함수 표현식: 정의한 function을 별도의 변수에 할당하는 것

    익명 함수 표현식: 함수명을 정의하지 않는 함수 표현식

    **변수명 b가 곧 함수명**

    ```js
    var b = function () {
      /*...*/
    };

    b(); // 실행 OK.
    ```

    기명 함수 표현식: 함수명을 정의한 함수 표현식

    **변수명은 c, 함수명은 d**

    ```js
    var c = function d() {
      /*...*/
    };

    c(); // 실행 OK.
    d(); // 에러!
    ```

  3. **함수 선언문과 함수 표현식 호이스팅**

  - 함수 선언문과 함수 표현식 호이스팅

    ```js
    var sum = functiono sum(a,b) { // 함수 선언문은 전체를 호이스팅함
        return a + b;
    };

    var multiply;                 //변수는 선엍부만 끌어올림

    console.log(sum(1, 2));
    console.log(multiply(3,4))

    multiply = function (a,b){
        return a*b;
    };
    ```

    ✏️ 함수 선언문의 위험성

    전역 컨텍스트가 활성화될 때 전역공간에 선언된 함수들이 모두 가장 위로 끌어올려짐

    동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌움

    따라서 코드를 실행하는 중에 실제로 호출되는 함수는 오직 마지막에 할당한 함수, 즉 맨 마지막에 선언된 함수뿐

- 2-3-2 스코프, 스코프 체인, outerEnvironmentReference

  **스코프**: 식별자에 대한 유효범위

  경계 A의 외부에서 선언한 변수는 A의 외부뿐 아니라 A의 내부에서도 접근이 가능하지만, A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근할 수 있다.

  **스코프 체인**: '식별자의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것

  **이를 가능케 하는 것이 바로 LexicalEnviroment의 두 번째 수집 자료인 outEnviromentReference**임

  **변수 은닉화** -> 스코프 체인 상에 있는 변수라고 해서 무조건 접근 가능한 것은 아님

  **지역 변수와 전역 변수**

### 2-4 this

this에는 실행 컨텍스트를 활성화 당시에 지정된 this가 저장됨
실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역 객체자 저장됨
